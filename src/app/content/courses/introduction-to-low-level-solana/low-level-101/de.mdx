import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Low-level 101

![Image Test](/graphics/banners/research-crateless-program.png)

Wenn du ein Solana-Programm geschrieben hast, weißt du sicherlich, dass alle grundlegenden Anforderungen an ein Programm wie Entrypoint, CPIs und Kontoverwaltung normalerweise von Crates wie solana_program und pinocchio übernommen werden, die unter der Haube von Frameworks wie anchor, steel, ... verwendet werden.

Aber um den Solana-Stack wirklich zu verstehen und zu optimieren, müssen wir hinter all diese Abstraktionen blicken und sehen, was unter der Haube passiert. In diesem Kurs werden wir ein vollständig handgeschriebenes Solana-Programm ohne Abhängigkeiten von Grund auf erstellen.

Bevor wir uns die verschiedenen handgeschriebenen Komponenten ansehen, müssen wir die grundlegenden Bausteine verstehen, die Solana-Programme zum Laufen bringen.

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Solana-Programme werden zu eBPF-Bytecode (extended Berkeley Packet Filter) kompiliert, nicht zu nativem Maschinencode. Diese architektonische Entscheidung erklärt viele Eigenheiten von Solana:
- **Compute-Unit-Limits**: Das Sicherheitsmodell von eBPF verhindert Endlosschleifen durch Zählen von Anweisungen
- **Keine Heap-Allokation**: eBPF-Programme laufen in einer Sandbox-Umgebung ohne malloc/free
- **Begrenzter Stack**: Nur 4KB Stack-Speicher erzwingt sorgfältiges Speichermanagement
- **Deterministische Ausführung**: Die gleichen Eingaben produzieren immer die gleichen Ausgaben auf allen Validatoren

Das erklärt, warum bestimmte Rust-Funktionen in Solana-Programmen einfach nicht funktionieren; die Laufzeitumgebung kann sie buchstäblich nicht ausführen.

<ArticleSection name="#[repr(C)] & extern `C`" id="repr-c-and-extern-c" level="h2" />

Wenn du dir ein beliebiges Low-Level-Solana-Beispiel ansiehst, tauchen zwei Muster überall auf:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

Weist den Rust-Compiler an, eine Funktion mit der C-ABI (Application Binary Interface) zu exponieren, der Aufrufkonvention, die definiert, welche eBPF-Register Argumente tragen, wie der Stack aufgebaut ist und welches Register Werte zurückgibt.

Die C-ABI wird gewählt, weil sie der kleinste gemeinsame Nenner für alle Sprachen ist, die LLVMs eBPF-Backend unterstützt: Rust, C, Zig oder sogar handgeschriebener Assembler-Code. Die Solana-Laufzeitumgebung muss den Einstiegspunkt deines Programms über den Rohnamen aufrufen und Parameter über bestimmte Register übergeben; die C-ABI garantiert, dass dies unabhängig von der Sprache funktioniert, die deinen Bytecode kompiliert hat.

**`#[repr(C)]`** 

Zwingt Rust dazu, Struct-Felder genau so anzuordnen, wie es ein C-Compiler tun würde, wodurch die Feldreihenfolge und -auffüllung fixiert werden, sodass sich das Byte-Layout niemals ändert:

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

Dies ist wichtig, weil Account-Daten zwischen Programmaufrufen bestehen bleiben. Wenn Rust die Felder zwischen Kompilierungen neu anordnet, kann dein Programm die zuvor geschriebenen Daten nicht mehr lesen.

<ArticleSection name="Memory Layout Management" id="memory-layout-management" level="h2" />

In High-Level-Frameworks geschieht die Speicherausrichtung automatisch. Auf niedriger Ebene zählt jedes Byte:

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

Die Regel für die Speicherverwaltung ist, dass jedes Feld an einem Offset beginnen muss, der durch seine eigene Größe teilbar ist:
- `u8`: Beliebiger Offset (teilbar durch 1)
- `u16`: Offset muss durch 2 teilbar sein (0, 2, 4...)
- `u32`: Offset muss durch 4 teilbar sein (0, 4, 8...)
- `u64`: Offset muss durch 8 teilbar sein (0, 8, 16...)

Dies ist wirklich wichtig, da eine falsche Speicherverwaltung zu nicht ausgerichteten Speicherzugriffen führen kann, die dein Programm unvorhersehbar zum Scheitern bringen können.

Wenn du die Serialisierung von Account-Daten manuell verwaltest, wird das Verständnis von Padding und Ausrichtung entscheidend für die programmübergreifende Kompatibilität.

#### Syscalls 

Ein **Systemaufruf** oder Syscall ist die Tür, durch die unprivilegierter Code einen privilegierten Dienst von seinem Host anfordert. Wenn ein Syscall ausgeführt wird, wechselt die CPU vom Benutzermodus in einen vertrauenswürdigen, privilegierten Modus; die Laufzeitumgebung führt dann die angeforderte Aktion aus, und die Kontrolle kehrt mit einem Statuscode zurück. Diese Indirektion verhindert, dass Sandbox-Code direkt auf Host-Speicher oder I/O zugreift, wodurch Sicherheit und Determinismus gewahrt bleiben.

Auf Solana kann BPF-Bytecode nicht von sich aus hashen, loggen oder einen Cross-Program-Aufruf (CPI) durchführen. Stattdessen ruft er benannte Syscalls auf, wie `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Jede Syscall-Nummer ist einfach ein Index in der Dispatch-Tabelle des Loaders. Der Loader führt die angeforderte Operation aus und gibt ein `u64` Statuswort zurück (Null für Erfolg, ungleich Null für Fehler).

Zum Beispiel verpackt `sol_invoke_signed` eine Anweisung, ihre Kontenliste und alle PDA-Signatur-Seeds, übergibt sie an den Loader, und der Loader führt den CPI unter der richtigen Autorität wie folgt aus:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Der Vault-Code" id="the-vault-code" level="h2" />

Nachdem wir jeden Baustein eines "crate-losen" Solana-Programms entpackt haben, können wir den Vault selbst skizzieren. Denken Sie daran, ein Vault macht genau zwei Dinge:
- **Einzahlen** von Lamports in eine PDA, die vom öffentlichen Schlüssel des Besitzers abgeleitet wird.
- **Abheben** derselben Lamports zu einem späteren Zeitpunkt; nur durch den Besitzer.

Jede Anweisung enthält daher drei Konten:
- **Besitzer** (Unterzeichner, beschreibbar): Der Benutzer, der Gelder einzahlt oder abhebt.
- **Vault** (beschreibbar): Eine PDA, in der alle Lamports enthalten sind.
- **System-Programm**: Konto, das für die Lamport-Übertragung benötigt wird.

Bevor wir beginnen, müssen wir ein neues Projekt erstellen. Führen Sie dazu diesen Befehl in Ihrem Terminal aus:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

In `Cargo.toml` fügen Sie hinzu:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Vorlage

Alles wird in `lib.rs` untergebracht. Auf einen Blick wird die Datei Syscall-Shims (kleine, #[repr(C)] Strukturen, die die rohen Syscall-Layouts spiegeln, die wir benötigen) und Datenoffsets als Konstanten enthalten (um die Arbeit mit Rohdaten zu erleichtern).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Kontoprüfungen

Bevor wir `deposit` oder `withdraw` ausführen können, muss der Einstiegspunkt sicherstellen, dass die Transaktion uns genau die richtigen Konten gegeben hat und dass jedes die erwarteten Flags aufweist.

Da wir auf der Ebene der rohen Zeiger arbeiten, wird jede Prüfung mit einfacher Zeigerarithmetik und direkten Ladevorgängen durchgeführt.

Die ersten acht Bytes des Eingabedatensatzes enthalten account_len. Für diesen Tresor erwarten wir drei Konten: Eigentümer, Tresor-PDA und das System-Programm:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Wir fahren mit der Überprüfung jedes Kontos fort. Die zuvor definierten Layout-Offsets ermöglichen es uns, jedes Flag zu überprüfen, ohne die vollständige Struktur zu deserialisieren.

Für das erste Konto, den Unterzeichner, führen wir folgende Prüfungen durch: 
- Muss eindeutig sein (is_duplicate == 0xff)
- Beschreibbar (wir werden seine Lamports ändern)
- Unterzeichner
- Nicht ausführbar
- Darf keine Daten haben 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Wir speichern auch den öffentlichen Schlüssel des Eigentümers für die spätere PDA-Prüfung:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Für das zweite Konto, den Tresor, führen wir folgende Prüfungen durch:
- Beschreibbar (wir werden seine Lamports ändern)
- Im Besitz des System-Programms
- Datenlänge muss null sein (wir speichern hier keinen Zustand)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Wir erfassen auch den öffentlichen Schlüssel des Tresors für die spätere PDA-Prüfung:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Für das letzte Konto, das System-Programm, führen wir folgende Prüfungen durch: 
- Muss ausführbar sein
- Sein Schlüssel muss mit SYSTEM_PROGRAM_ID übereinstimmen

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Anweisungsprüfungen

Nach der Kontovalidierung können wir endlich die Anweisungsnutzlast parsen. Wir verwenden den gleichen Ansatz wie ein natives Programm, indem wir das erste Byte als Diskriminator verwenden:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

Von hier aus verzweigen wir entweder in den Einzahlungs- oder Auszahlungshandler, in der Gewissheit, dass jedes Konto und jedes Flag genau den Erwartungen des Tresors entspricht.

#### Einzahlungslogik

Wir beginnen mit einer detaillierteren Durchsicht der Einzahlungsanweisung. Alle Prüfungen stehen am Anfang; sobald sie bestanden sind, erstellen wir eine System-Programm-Überweisung und führen sie aus.

Die Instruktionsdaten dieser Anweisung sehen wie folgt aus:
- Byte 0 ist der Diskriminator (`0x00` für Einzahlung).
- Byte 1 ist der Bump, den du für die PDA-Prüfung wiederverwenden wirst.
- Bytes 2-9 enthalten den Lamport-Betrag in Little-Endian, der geprüft und abgelehnt wird, wenn er 0 beträgt.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Danach hashen wir den Owner-Schlüssel mit dem `sol_sha256` Syscall, mit dem Bump, der Programm-ID und dem eindeutigen String "ProgramDerivedAddress". 

Wir vergleichen das Ergebnis mit dem Vault-Schlüssel, den wir während der Kontoprüfungen gespeichert haben. Wenn sie sich unterscheiden, wird `InvalidSeeds` zurückgegeben.

Wenn sie sich unterscheiden, wird `InvalidSeeds` zurückgegeben.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Schließlich können wir endlich die System-Programm-Überweisung erstellen. 

Das System-Programm verwendet einen vier Byte langen Diskriminator (für Überweisungen ist dieser Wert 2) und benötigt zusätzlich 8 Bytes, die den Betrag darstellen, den wir vom `from_account` zum `to_account` überweisen möchten

Dann müssen wir ein kleines Array von zwei SolAccountMeta-Werten erstellen: from = owner (Unterzeichner, beschreibbar), to = vault (beschreibbar). Wir kombinieren das mit dem `instruction_data`, um eine `SolInstruction`Struktur zu erstellen:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Aber bevor wir den `sol_invoke_signed_c` Syscall aufrufen, müssen wir zwei `SolAccountInfo`Strukturen erstellen, eine für den Owner und eine für den
Vault, die Zeiger auf ihre Lamport-Guthaben und Datenschnitte genau dort liefern, wo der Loader sie im Speicher hinterlassen hat.

Danach können wir den Syscall aufrufen, indem wir den Anweisungszeiger, den Zeiger auf dein zweielementiges `SolAccountInfo`Array und die Kontoanzahl (2) übergeben. Da die äußere Transaktion bereits vom Owner signiert ist, werden hier keine PDA-Seeds benötigt, daher ist das `signers_seeds_addr`Argument NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Auszahlungslogik

Die Auszahlungsanweisung ist ähnlich wie die Einzahlung, weist jedoch einige wichtige Unterschiede auf. Die Anweisungsdaten sind einfacher:
- Byte 0 ist der Diskriminator (`0x01` für Auszahlung).
- Byte 1 ist der Bump, den du für die PDA-Prüfung wiederverwenden wirst.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Wir führen die gleiche PDA-Prüfung wie bei der Einzahlung durch, unter Verwendung des öffentlichen Schlüssels des Eigentümers, des Bumps, der Programm-ID und des eindeutigen Strings "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Der Hauptunterschied bei der Auszahlung besteht darin, dass wir die Transaktion mit dem PDA selbst signieren müssen. Dazu müssen wir die Seeds angeben, die zur Ableitung des PDA verwendet wurden. Wir erstellen ein `SolSignerSeedsC`Array mit zwei Elementen:
- Der öffentliche Schlüssel des Eigentümers (32 Bytes)
- Der Bump (1 Byte)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Dann erstellen wir die System-Programm-Überweisungsanweisung, diesmal jedoch vom Tresor zum Eigentümer. Die Anweisungsdaten sind die gleichen wie bei der Einzahlung:
- Vier-Byte-Diskriminator (Wert 2 für Überweisung)
- Acht Bytes für den Betrag (den wir aus den Lamports des Tresors erhalten)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Die Account-Metas sind im Vergleich zur Einzahlung umgekehrt:
- Erstes Konto ist der Tresor (beschreibbar, Unterzeichner)
- Zweites Konto ist der Eigentümer (beschreibbar)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Schließlich rufen wir `sol_invoke_signed_c` mit der Anweisung, den Account-Infos und den zuvor erstellten Unterzeichner-Seeds auf:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Abschließende Bemerkungen" id="closing-remarks" level="h2" />

Obwohl dieser Low-Level-Ansatz zum Schreiben von Solana-Programmen extrem erscheinen mag, dient er einem wichtigen Bildungszweck. Wir empfehlen nicht, deine Programme auf diese Weise zu schreiben; tatsächlich raten wir dringend dazu, etablierte Frameworks und Crates zu verwenden, die diese Komplexitäten abstrahieren. Das Verständnis der zugrundeliegenden Mechanismen ist jedoch von unschätzbarem Wert.

Jede Abstraktion, die wir in der Solana-Entwicklung verwenden, sei es `solana_program`, `anchor` oder jedes andere Framework, baut auf diesen grundlegenden Bausteinen auf. Indem wir die Schichten zurückziehen und die rohen Mechanismen untersuchen, gewinnen wir ein tieferes Verständnis für:

1. Wie die Solana-Laufzeitumgebung mit unseren Programmen interagiert
2. Warum bestimmte Designentscheidungen in höheren Frameworks getroffen wurden
3. Wo potenzielle Optimierungen existieren könnten
4. Wie man Probleme besser debuggen kann, wenn sie auftreten

Dieses Wissen ist nicht nur akademisch; es ist praktisch. Wenn du die Grundlagen verstehst, kannst du:
- Effizientere Programme schreiben, indem du informierte Entscheidungen über Datenstrukturen und Speichernutzung triffst
- Probleme besser diagnostizieren und beheben, wenn sie auftreten
- Zum Ökosystem beitragen, indem du die Tools verbesserst, die wir alle nutzen
- Fundierte Entscheidungen darüber treffen, wann bestimmte Abstraktionen verwendet werden sollten und wann näher am Metal gearbeitet werden sollte

Denk daran, das Ziel dieser Übung war nicht, dir beizubringen, wie man Programme ohne Crates schreibt, sondern dir zu helfen zu verstehen, was diese Crates unter der Haube tun. Dieses Verständnis ist der erste Schritt zum Schreiben besserer, effizienterer Solana-Programme, unabhängig davon, welche Tools du verwenden möchtest.
