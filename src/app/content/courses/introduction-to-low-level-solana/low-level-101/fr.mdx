import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Niveau bas 101

![Test d'image](/graphics/banners/research-crateless-program.png)

Si vous avez écrit un programme Solana, vous savez certainement que tous les besoins de base d'un programme comme un point d'entrée, les CPIs et la gestion des comptes sont généralement gérés par des crates comme solana_program et pinocchio, qui sont utilisés en arrière-plan par des frameworks comme anchor, steel, ...

Mais pour vraiment comprendre et optimiser la stack Solana, nous devons regarder derrière toutes ces abstractions et voir ce qui se passe sous le capot. Dans ce cours, nous allons créer un programme Solana entièrement fait à la main, sans aucune dépendance, à partir de zéro.

Avant d'examiner les différents composants faits à la main, nous devons comprendre les éléments fondamentaux qui font fonctionner les programmes Solana.

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Les programmes Solana sont compilés en bytecode eBPF (extended Berkeley Packet Filter), et non en code machine natif. Ce choix architectural explique de nombreuses particularités de Solana :
- **Limites d'unités de calcul** : le modèle de sécurité d'eBPF empêche les boucles infinies en comptant les instructions
- **Pas d'allocation dynamique** : les programmes eBPF s'exécutent dans un environnement sandbox sans malloc/free
- **Stack limitée** : seulement 4 Ko d'espace de pile impose une gestion minutieuse de la mémoire
- **Exécution déterministe** : les mêmes entrées produisent toujours les mêmes sorties sur tous les validateurs

Cela explique pourquoi certaines fonctionnalités de Rust ne fonctionnent tout simplement pas dans les programmes Solana ; le runtime ne peut littéralement pas les exécuter.

<ArticleSection name="#[repr(C)] & extern `C`" id="repr-c-and-extern-c" level="h2" />

Lorsque vous examinez n'importe quel exemple Solana de bas niveau, deux modèles apparaissent partout :

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

Indique au compilateur Rust d'exposer une fonction en utilisant l'ABI C (Application Binary Interface), la convention d'appel qui définit quels registres eBPF portent les arguments, comment la pile est organisée et quel registre renvoie les valeurs.

L'ABI C est choisie car c'est le plus petit dénominateur commun entre tous les langages que le backend eBPF de LLVM prend en charge : Rust, C, Zig, ou même l'assembleur écrit à la main. L'environnement d'exécution de Solana doit appeler le point d'entrée de votre programme par son nom brut et passer des paramètres via des registres spécifiques ; l'ABI C garantit que cela fonctionne quel que soit le langage qui a compilé votre bytecode.

**`#[repr(C)]`** 

Force Rust à organiser les champs de structure exactement comme le ferait un compilateur C, en verrouillant l'ordre des champs et le remplissage afin que la disposition des octets ne change jamais :

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

C'est important car les données du compte persistent entre les invocations du programme. Si Rust réorganise vos champs entre les compilations, votre programme ne pourra pas lire les données qu'il a écrites précédemment.

<ArticleSection name="Gestion de la disposition mémoire" id="memory-layout-management" level="h2" />

Dans les frameworks de haut niveau, l'alignement mémoire se fait automatiquement. Au niveau bas, chaque octet compte :

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

La règle pour la gestion de la mémoire est que chaque champ doit commencer à un décalage divisible par sa propre taille :
- `u8` : N'importe quel décalage (divisible par 1)
- `u16` : Le décalage doit être divisible par 2 (0, 2, 4...)
- `u32` : Le décalage doit être divisible par 4 (0, 4, 8...)
- `u64` : Le décalage doit être divisible par 8 (0, 8, 16...)

C'est vraiment important car une mauvaise gestion de la mémoire peut conduire à des accès mémoire mal alignés qui peuvent faire échouer votre programme de manière imprévisible.

Lorsque vous gérez manuellement la sérialisation des données de compte, comprendre le remplissage et l'alignement devient crucial pour la compatibilité entre programmes.

#### Appels système

Un **appel système**, ou syscall, est la porte par laquelle un code non privilégié demande un service privilégié à son hôte. Lorsqu'un appel système est effectué, le CPU passe du mode utilisateur à un mode privilégié et fiable ; l'environnement d'exécution effectue alors l'action demandée, et le contrôle revient avec un code d'état. Cette indirection empêche le code en bac à sable de toucher directement la mémoire ou les E/S de l'hôte, préservant ainsi la sécurité et le déterminisme.

Sur Solana, le bytecode BPF ne peut pas effectuer de hachage, de journalisation ou d'invocation inter-programme (CPI) par lui-même. Au lieu de cela, il invoque des appels système nommés tels que `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Chaque numéro d'appel système est simplement un index dans la table de distribution du chargeur. Le chargeur exécute l'opération demandée et renvoie un mot d'état `u64` (zéro pour succès, non-zéro pour échec).

Par exemple, `sol_invoke_signed` empaquette une instruction, sa liste de comptes et les seeds de signataire PDA, les transmet au chargeur, et le chargeur effectue le CPI sous l'autorité appropriée comme ceci :

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Le code du coffre-fort" id="the-vault-code" level="h2" />

Maintenant que nous avons décomposé chaque élément constitutif d'un programme Solana "sans crate", nous pouvons décrire le coffre-fort lui-même. Rappelez-vous, un coffre-fort fait exactement deux choses :
- **Déposer** des lamports dans un PDA dérivé de la clé publique du propriétaire.
- **Retirer** ces mêmes lamports plus tard ; uniquement par le propriétaire.

Chaque instruction transportera donc trois comptes :
- **Propriétaire** (signataire, modifiable) : L'utilisateur qui dépose ou retire des fonds.
- **Coffre-fort** (modifiable) : Un PDA où tous les lamports sont contenus.
- **Programme système** : compte nécessaire pour effectuer le transfert de lamports.

Avant de commencer, nous devons créer un nouveau projet. Pour ce faire, exécutez cette commande dans votre terminal :

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

Dans `Cargo.toml` ajoutez :

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Modèle

Tout sera dans `lib.rs`. En un coup d'œil, le fichier contiendra des Shims d'appels système (petites structures #[repr(C)] qui reflètent les dispositions brutes des appels système dont nous aurons besoin), et des décalages de données comme constantes (pour faciliter le travail avec les données brutes).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Vérifications de compte

Avant de pouvoir exécuter `deposit` ou `withdraw`, le point d'entrée doit s'assurer que la transaction nous a fourni exactement les bons comptes et que chacun possède les indicateurs attendus.

Comme nous travaillons au niveau des pointeurs bruts, chaque vérification est effectuée avec de simples calculs de pointeurs et des chargements directs.

Les huit premiers octets de l'enregistrement d'entrée contiennent account_len. Pour ce coffre-fort, nous attendons trois comptes : le propriétaire, le PDA du coffre-fort et le Programme Système :

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Nous continuons en vérifiant chaque compte, les décalages de mise en page que nous avons définis précédemment nous permettent de vérifier chaque indicateur sans désérialiser la structure complète.

Pour le premier compte, le signataire, voici les vérifications que nous effectuons : 
- Doit être unique (is_duplicate == 0xff)
- Modifiable (nous changerons ses lamports)
- Signataire
- Non exécutable
- Ne doit pas avoir de données 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Nous conservons également la clé publique du propriétaire pour la vérification PDA ultérieure :

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Pour le deuxième compte, le coffre-fort, voici les vérifications que nous effectuons :
- Modifiable (nous changerons ses lamports)
- Détenu par le Programme Système
- La longueur des données doit être zéro (nous ne stockons pas d'état ici)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Nous récupérons également la clé publique du coffre-fort pour la vérification PDA ultérieure :

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Pour le dernier compte, le programme système, voici les vérifications que nous effectuons : 
- Doit être exécutable
- Sa clé doit être égale à SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Vérifications d'instruction

Après la validation des comptes, nous pouvons enfin analyser la charge utile de l'instruction. Et nous adoptons la même approche qu'un programme natif en utilisant le premier octet comme discriminateur :

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

À partir de là, nous nous dirigeons soit vers le gestionnaire de dépôt, soit vers celui de retrait, confiants que chaque compte et indicateur correspond exactement à ce que le coffre-fort attend.

#### Logique de dépôt

Nous allons commencer par une analyse plus détaillée de l'instruction de dépôt. Toutes les vérifications sont placées en amont ; une fois qu'elles sont validées, nous créons un transfert du Programme Système et l'invoquons.

Les données d'instruction de cette instruction ressemblent à ceci :
- L'octet 0 est le discriminateur (`0x00` pour le dépôt).
- L'octet 1 est le bump que vous réutiliserez pour la vérification PDA.
- Les octets 2-9 contiennent le montant en lamports en little-endian qui sera vérifié et rejeté s'il équivaut à 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Ensuite, nous hachons la clé du propriétaire en utilisant l'appel système `sol_sha256`, avec le bump, l'ID du programme et la chaîne unique "ProgramDerivedAddress".

Nous comparons le résultat avec la clé du coffre que nous avons stockée lors des vérifications de compte. S'ils diffèrent, cela renvoie `InvalidSeeds`.

S'ils diffèrent, cela renvoie `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Enfin, nous pouvons créer le transfert du System-Program.

Le System Program utilise un discriminateur de quatre octets (pour le transfert, cette valeur est 2) et nécessite 8 octets supplémentaires qui représentent le montant que nous voulons transférer du `from_account` vers le `to_account`

Nous devons ensuite construire un petit tableau de deux valeurs SolAccountMeta : from = owner (signataire, modifiable), to = vault (modifiable). Nous combinons cela avec le `instruction_data` pour créer une structure `SolInstruction` :

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Mais avant d'appeler l'appel système `sol_invoke_signed_c`, nous devons construire deux structures `SolAccountInfo`, une pour le propriétaire et une pour le
coffre qui fournit des pointeurs vers leurs soldes de lamports et tranches de données exactement là où le chargeur les a laissés en mémoire.

Après cela, nous pouvons appeler l'appel système en passant le pointeur d'instruction, le pointeur vers votre tableau `SolAccountInfo` à deux éléments, et le nombre de comptes (2). Comme la transaction externe est déjà signée par le propriétaire, aucune graine PDA n'est nécessaire ici, donc l'argument `signers_seeds_addr` est NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Logique de retrait

L'instruction de retrait est similaire au dépôt, mais avec quelques différences clés. Les données d'instruction sont plus simples :
- L'octet 0 est le discriminateur (`0x01` pour le retrait).
- L'octet 1 est le bump que vous réutiliserez pour la vérification du PDA.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Nous effectuons la même vérification PDA que lors du dépôt, en utilisant la clé publique du propriétaire, le bump, l'ID du programme et la chaîne unique "ProgramDerivedAddress" :

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

La différence clé dans le retrait est que nous devons signer la transaction avec le PDA lui-même. Pour ce faire, nous devons fournir les seeds qui ont été utilisés pour dériver le PDA. Nous créons un tableau `SolSignerSeedsC` avec deux éléments :
- La clé publique du propriétaire (32 octets)
- Le bump (1 octet)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Nous élaborons ensuite l'instruction de transfert du System Program, mais cette fois du coffre vers le propriétaire. Les données d'instruction sont les mêmes que pour le dépôt :
- Discriminateur de quatre octets (valeur 2 pour le transfert)
- Huit octets pour le montant (que nous obtenons des lamports du coffre)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Les metas de compte sont inversés par rapport au dépôt :
- Le premier compte est le coffre (modifiable, signataire)
- Le deuxième compte est le propriétaire (modifiable)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Enfin, nous appelons `sol_invoke_signed_c` avec l'instruction, les informations de compte et les seeds de signataire que nous avons créés précédemment :

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Remarques finales" id="closing-remarks" level="h2" />

Bien que cette approche de bas niveau pour écrire des programmes Solana puisse sembler extrême, elle sert un objectif éducatif crucial. Nous ne suggérons pas que vous écriviez vos programmes de cette façon ; en fait, nous recommandons vivement d'utiliser des frameworks et des crates établis qui abstraient ces complexités. Cependant, comprendre les mécanismes sous-jacents est inestimable.

Chaque abstraction que nous utilisons dans le développement Solana, qu'il s'agisse de `solana_program`, `anchor`, ou de tout autre framework, est construite sur ces blocs fondamentaux. En décortiquant les couches et en examinant les mécanismes bruts, nous acquérons une appréciation plus profonde de :

1. Comment le runtime Solana interagit avec nos programmes
2. Pourquoi certaines décisions de conception ont été prises dans les frameworks de plus haut niveau
3. Où pourraient exister des optimisations potentielles
4. Comment mieux déboguer les problèmes lorsqu'ils surviennent

Cette connaissance n'est pas seulement académique ; elle est pratique. Lorsque vous comprenez les fondements, vous pouvez :
- Écrire des programmes plus efficaces en prenant des décisions éclairées sur les structures de données et l'utilisation de la mémoire
- Mieux diagnostiquer et résoudre les problèmes lorsqu'ils surviennent
- Contribuer à l'écosystème en améliorant les outils que nous utilisons tous
- Prendre des décisions éclairées sur quand utiliser certaines abstractions et quand travailler plus près du métal

Rappelez-vous, l'objectif de cet exercice n'était pas de vous apprendre à écrire des programmes sans crates, mais plutôt de vous aider à comprendre ce que ces crates font sous le capot. Cette compréhension est la première étape vers l'écriture de programmes Solana meilleurs et plus efficaces, quel que soit les outils que vous choisissez d'utiliser.
