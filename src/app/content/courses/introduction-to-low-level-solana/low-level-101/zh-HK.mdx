import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 低層基礎 101

![圖片測試](/graphics/banners/research-crateless-program.png)

如果你曾經編寫過 Solana 程式，你一定知道，像 Entrypoint、CPI 和帳戶管理等程式的基本需求通常由 solana_program 和 pinocchio 這類的 crate 處理，而這些 crate 又被 anchor、steel 等框架在底層使用。

但要真正理解和優化 Solana 堆疊，我們需要深入了解這些抽象背後的運作原理。在這門課程中，我們將從零開始，手動編寫一個完全無依賴的 Solana 程式。

在我們探討不同的手動編寫元件之前，我們需要了解構成 Solana 程式運作的基本構建模塊。

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Solana 程式會編譯為 eBPF（擴展伯克利封包過濾器）位元碼，而不是原生機器碼。這種架構選擇解釋了許多 Solana 的特性：
- **計算單元限制**：eBPF 的安全模型通過計算指令來防止無限迴圈
- **無堆分配**：eBPF 程式在無 malloc/free 的沙盒環境中運行
- **堆疊限制**：只有 4KB 的堆疊空間，需謹慎管理記憶體
- **確定性執行**：相同的輸入在所有驗證者中始終產生相同的輸出

這解釋了為什麼某些 Rust 特性在 Solana 程式中無法使用；因為運行時根本無法執行它們。

<ArticleSection name="#[repr(C)] & extern `C`" id="repr-c-and-extern-c" level="h2" />

當你查看任何低層 Solana 範例時，兩個模式隨處可見：

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

告訴 Rust 編譯器使用 C ABI（應用程式二進位介面）來暴露函數，這種調用約定定義了哪些 eBPF 寄存器攜帶參數、堆疊如何佈局以及哪些寄存器返回值。

選擇 C ABI 是因為它是 LLVM 的 eBPF 後端所支持的所有語言（如 Rust、C、Zig，甚至是手寫的組合語言）之間的最低共同標準。Solana 運行時需要通過原始名稱調用您的程式入口點，並通過特定的寄存器傳遞參數；C ABI 保證無論哪種語言編譯您的位元碼，這都能正常運作。

**`#[repr(C)]`**

強制 Rust 將結構體字段的排列方式與 C 編譯器完全一致，鎖定字段順序和填充，確保位元佈局永遠不會改變：

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

這很重要，因為帳戶數據在程式調用之間是持久的。如果 Rust 在編譯過程中重新排列了您的字段，您的程式將無法讀取之前寫入的數據。

<ArticleSection name="記憶體佈局管理" id="memory-layout-management" level="h2" />

在高級框架中，記憶體對齊是自動完成的。在低級別中，每個位元都很重要：

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

記憶體管理的規則是每個字段必須從一個能被其自身大小整除的偏移量開始：
- `u8`：任何偏移量（能被 1 整除）
- `u16`：偏移量必須能被 2 整除（0, 2, 4...）
- `u32`：偏移量必須能被 4 整除（0, 4, 8...）
- `u64`：偏移量必須能被 8 整除（0, 8, 16...）

這非常重要，因為記憶體管理不當可能導致未對齊的記憶體訪問，從而導致程式不可預測地失敗。

當您手動管理帳戶數據序列化時，理解填充和對齊對於跨程式的兼容性至關重要。

#### 系統調用

一個**系統調用**（syscall）是非特權代碼向其主機請求特權服務的入口。當進行系統調用時，CPU 會從用戶模式切換到受信任的特權模式；運行時隨後執行請求的操作，並返回一個狀態碼。這種間接方式防止了沙盒代碼直接接觸主機記憶體或 I/O，從而保證了安全性和確定性。

在 Solana 上，BPF bytecode 無法自行進行雜湊、記錄或執行跨程式調用（CPI）。相反，它會調用命名的系統呼叫，例如 `sol_log`、`sol_sha256`、`sol_invoke_signed`。

每個系統呼叫號碼只是加載器調度表中的一個索引。加載器執行請求的操作並返回一個 `u64` 狀態字（成功為零，失敗為非零）。

例如，`sol_invoke_signed` 將指令、其帳戶列表和任何 PDA 簽名者種子打包，交給加載器，而加載器在適當的授權下執行 CPI，如下所示：

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="The Vault Code" id="the-vault-code" level="h2" />

現在我們已經拆解了「無 crate」Solana 程式的每個構建塊，我們可以概述保險庫本身。請記住，保險庫只執行兩件事：
- **存入** lamports 到從擁有者公鑰派生的 PDA。
- **提取**相同的 lamports；僅限擁有者提取。

因此，每個指令將攜帶三個帳戶：
- **擁有者**（簽名者，可寫入）：存入或提取資金的用戶。
- **保險庫**（可寫入）：包含所有 lamports 的 PDA。
- **系統程式**：執行 lamport 轉移所需的帳戶。

在開始之前，我們需要創建一個新項目，為此請在終端中運行以下命令：

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

在 `Cargo.toml` 中添加：

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### 模板

所有內容將存放在 `lib.rs` 中。簡單來看，該文件將包含系統呼叫填充（小型 #[repr(C)] 結構體，反映我們需要的原始系統呼叫佈局）和作為常量的數據偏移量（以便更輕鬆地處理原始數據）。

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### 帳戶檢查

在我們運行 `deposit` 或 `withdraw` 之前，入口點必須確保交易提供了完全正確的帳戶，並且每個帳戶都具有預期的標誌。

由於我們在操作原始指針層級，每個檢查都是通過簡單的指針運算和直接加載完成的。

輸入記錄的前八個字節保存了 account_len。對於這個保險庫，我們預期有三個賬戶：擁有者、保險庫 PDA 和系統程序：

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

我們繼續檢查每個賬戶，之前定義的佈局偏移量讓我們可以在不反序列化整個結構的情況下檢查每個標誌的合理性。

對於第一個賬戶（簽署者），我們執行以下檢查：
- 必須是唯一的（is_duplicate == 0xff）
- 可寫（我們將更改其 lamports）
- 簽署者
- 不可執行
- 必須沒有數據

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我們還會存儲擁有者的公鑰，以便稍後進行 PDA 檢查：

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

對於第二個賬戶（保險庫），我們執行以下檢查：
- 可寫（我們將更改其 lamports）
- 由系統程序擁有
- 數據長度必須為零（我們不在此存儲狀態）

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我們還會提取保險庫的公鑰，以便稍後進行 PDA 檢查：

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

對於最後一個賬戶（系統程序），我們執行以下檢查：
- 必須是可執行的
- 其密鑰必須等於 SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### 指令檢查

在賬戶驗證之後，我們終於可以解析指令的有效負載。我們採用與本地程序相同的方法，使用第一個字節作為區分符：

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

從這裡，我們分支到存款或提款處理程序，確保每個賬戶和標誌完全符合保險庫的預期。

#### 存款邏輯

我們將從存款指令的更詳細的演練開始。所有檢查都在前面；一旦通過，我們構建一個系統程序轉賬並調用它。

此指令的指令數據如下：
- 字節 0 是識別碼（`0x00` 表示存款）。
- 字節 1 是您將重用於 PDA 檢查的 bump 值。
- 字節 2-9 以小端格式存儲 lamport 數量，如果為 0，則會被檢查並拒絕。

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

之後，我們使用 `sol_sha256` 系統調用對擁有者密鑰進行哈希處理，結合 bump 值、程序 ID 和唯一字符串 "ProgramDerivedAddress"。

我們將結果與在帳戶檢查期間存儲的保管庫密鑰進行比較。如果它們不同，則返回 `InvalidSeeds`。

如果它們不同，則返回 `InvalidSeeds`。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

最後，我們終於可以構建 System-Program 轉賬了。

System Program 使用四字節識別碼（對於轉賬，該值為 2），並需要額外的 8 字節來表示我們希望從 `from_account` 轉賬到 `to_account` 的金額。

然後我們需要構建一個包含兩個 SolAccountMeta 值的小型數組：from = owner（簽名者，可寫），to = vault（可寫）。我們將其與 `instruction_data` 結合以創建一個 `SolInstruction` 結構：

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

但在調用 `sol_invoke_signed_c` 系統調用之前，我們需要構建兩個 `SolAccountInfo` 結構，一個用於擁有者，一個用於保管庫，提供指向其 lamport 餘額和數據片段的指針，這些指針正好位於加載器在內存中留下的位置。

之後，我們可以通過傳遞指令指針、指向兩元素 `SolAccountInfo` 數組的指針以及帳戶數量（2）來調用系統調用。由於外部交易已由擁有者簽名，因此此處不需要 PDA 種子，因此 `signers_seeds_addr` 參數為 NULL。

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### 提取邏輯

提取指令與存款指令相似，但有幾個關鍵的不同之處。指令數據較為簡單：
- 字節 0 是識別碼（`0x01` 表示提取）。
- 字節 1 是您將重用於 PDA 檢查的 bump 值。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

我們執行與存款相同的 PDA 檢查，使用擁有者的公鑰、bump 值、程序 ID 和唯一字符串 "ProgramDerivedAddress"：

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

提取的關鍵不同之處在於我們需要使用 PDA 本身簽署交易。為此，我們需要提供用於推導 PDA 的種子。我們創建一個 `SolSignerSeedsC` 陣列，包含兩個元素：
- 擁有者的公鑰（32 字節）
- bump 值（1 字節）

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

然後，我們構建系統程序的轉賬指令，但這次是從保管庫到擁有者。指令數據與存款相同：
- 四字節識別碼（值為 2，表示轉賬）
- 八字節的金額（從保管庫的 lamports 獲取）

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

賬戶元數據與存款相比是反向的：
- 第一個賬戶是保管庫（可寫入，簽署者）
- 第二個賬戶是擁有者（可寫入）

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

最後，我們使用指令、賬戶信息和之前創建的簽署種子調用 `sol_invoke_signed_c`：

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="結語" id="closing-remarks" level="h2" />

雖然這種低層次的 Solana 程序編寫方法看起來極端，但它具有重要的教育意義。我們並不建議您以這種方式編寫程序；事實上，我們強烈建議使用已建立的框架和庫來抽象掉這些複雜性。然而，理解底層機制是非常有價值的。

在 Solana 開發中，我們使用的每一個抽象層，不論是 `solana_program`、`anchor`，還是其他框架，都是建立在這些基本構建塊之上的。通過剝開層層結構並檢視其底層機制，我們可以更深入地理解：

1. Solana 運行時如何與我們的程式互動
2. 為什麼高階框架會做出某些設計決策
3. 哪些地方可能存在潛在的優化空間
4. 當問題發生時，如何更好地進行除錯

這些知識不僅僅是學術性的，而是實用的。當你理解了基礎，你可以：
- 通過對資料結構和記憶體使用的知情決策，撰寫更高效的程式
- 更好地診斷和修復問題
- 通過改進我們共同使用的工具，為生態系統作出貢獻
- 在使用某些抽象層與更接近底層操作之間做出明智的選擇

請記住，這次練習的目標不是教你如何在沒有 crates 的情況下撰寫程式，而是幫助你理解這些 crates 在底層的運作方式。這種理解是撰寫更好、更高效的 Solana 程式的第一步，無論你選擇使用哪種工具。
