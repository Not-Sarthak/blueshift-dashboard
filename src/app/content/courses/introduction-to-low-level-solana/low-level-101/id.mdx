import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Low-level 101

![Image Test](/graphics/banners/research-crateless-program.png)

Jika Anda pernah menulis program Solana, Anda pasti tahu bahwa semua kebutuhan dasar untuk program seperti Entrypoint, CPI, dan manajemen akun biasanya ditangani oleh crate seperti solana_program dan pinocchio, yang digunakan di balik layar oleh framework seperti anchor, steel, ...

Tetapi untuk benar-benar memahami dan mengoptimalkan stack Solana, kita perlu melihat di balik semua abstraksi ini dan melihat apa yang terjadi di balik layar. Dalam kursus ini, kita akan membuat program Solana yang sepenuhnya dibuat secara manual, tanpa dependensi dari awal.

Sebelum kita melihat komponen yang dibuat secara manual, kita perlu memahami blok bangunan fundamental yang membuat program Solana berfungsi.

<ArticleSection name="eBPF" id="eBPF" level="h2" />

Program Solana dikompilasi menjadi bytecode eBPF (extended Berkeley Packet Filter), bukan kode mesin asli. Pilihan arsitektur ini menjelaskan banyak keunikan Solana:
- **Batas unit komputasi**: model keamanan eBPF mencegah loop tak terbatas dengan menghitung instruksi
- **Tidak ada alokasi heap**: program eBPF berjalan di lingkungan sandbox tanpa malloc/free
- **Stack terbatas**: Hanya 4KB ruang stack memaksa manajemen memori yang hati-hati
- **Eksekusi deterministik**: Input yang sama selalu menghasilkan output yang sama di semua validator

Ini menjelaskan mengapa fitur Rust tertentu tidak berfungsi dalam program Solana; runtime secara harfiah tidak dapat mengeksekusinya.

<ArticleSection name="#[repr(C)] & extern `C`" id="repr-c-and-extern-c" level="h2" />

Ketika Anda melihat contoh Solana tingkat rendah, dua pola muncul di mana-mana:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

**`extern "C"`**

Memberi tahu kompiler Rust untuk mengekspos fungsi menggunakan ABI C (Application Binary Interface), konvensi pemanggilan yang mendefinisikan register eBPF mana yang membawa argumen, bagaimana stack disusun dan register mana yang mengembalikan nilai.

ABI C dipilih karena merupakan penyebut umum terendah di semua bahasa yang didukung oleh backend eBPF LLVM: Rust, C, Zig, atau bahkan assembly yang ditulis secara manual. Runtime Solana perlu memanggil entrypoint program Anda dengan nama mentah dan meneruskan parameter melalui register tertentu; ABI C menjamin ini berfungsi terlepas dari bahasa apa yang mengompilasi bytecode Anda.

**`#[repr(C)]`** 

Memaksa Rust untuk mengatur bidang struct persis seperti yang dilakukan kompiler C, mengunci urutan bidang dan padding sehingga tata letak byte tidak pernah berubah:

```rust
// Without #[repr(C)] - Rust can reorder these fields for optimization!
struct UnpredictableState {
    amount: u64,     // Could be at offset 0, 8, or 16
    owner: [u8; 32], // Position depends on compiler mood
    bump: u8,        // Might get packed or padded anywhere
}

// With #[repr(C)] - Layout is guaranteed and predictable
#[repr(C)]
struct PredictableState {
    amount: u64,     // Always at offset 0
    owner: [u8; 32], // Always at offset 8  
    bump: u8,        // Always at offset 40
    // Implicit padding: 7 bytes to align to 8-byte boundary
}
```

Ini penting karena data akun tetap ada di antara pemanggilan program. Jika Rust mengubah urutan bidang Anda antara kompilasi, program Anda tidak akan dapat membaca data yang ditulis sebelumnya.

<ArticleSection name="Memory Layout Management" id="memory-layout-management" level="h2" />

Dalam framework tingkat tinggi, penyesuaian memori terjadi secara otomatis. Pada tingkat rendah, setiap byte penting:

```rust
rust#[repr(C)]
struct BadAlignment {
    flag: u8,        // 1 byte
    // Compiler inserts 7 bytes of padding here
    amount: u64,     // 8 bytes - needs 8-byte alignment!
    owner: [u8; 32], // 32 bytes
} // Total: 48 bytes (not 41!)

#[repr(C)]  
struct GoodAlignment {
    amount: u64,     // 8 bytes - naturally aligned
    owner: [u8; 32], // 32 bytes  
    flag: u8,        // 1 byte
    // Only 7 bytes of padding at the end
} // Total: 48 bytes, but padding is predictable
```

Aturan untuk manajemen memori adalah bahwa setiap bidang harus dimulai pada offset yang dapat dibagi dengan ukurannya sendiri:
- `u8`: Offset apa pun (dapat dibagi dengan 1)
- `u16`: Offset harus dapat dibagi dengan 2 (0, 2, 4...)
- `u32`: Offset harus dapat dibagi dengan 4 (0, 4, 8...)
- `u64`: Offset harus dapat dibagi dengan 8 (0, 8, 16...)

Ini sangat penting karena kesalahan pengelolaan memori dapat menyebabkan akses memori yang tidak selaras yang dapat menyebabkan program Anda gagal secara tidak terduga. 

Ketika Anda mengelola serialisasi data akun secara manual, memahami padding dan alignment menjadi penting untuk kompatibilitas antar program.

#### Syscalls 

**System call**, atau syscall, adalah pintu masuk yang melaluinya kode tanpa hak istimewa meminta layanan dari host-nya. Ketika syscall dibuat, CPU beralih dari mode pengguna ke mode istimewa yang terpercaya; runtime kemudian melakukan tindakan yang diminta, dan kontrol kembali dengan kode status. Pengalihan ini mencegah kode yang di-sandbox menyentuh memori host atau I/O secara langsung, menjaga keamanan dan determinisme.

Pada Solana, bytecode BPF tidak dapat melakukan hash, log, atau melakukan cross-program invocation (CPI) dengan sendirinya. Sebagai gantinya, ia memanggil syscall bernama seperti `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Setiap nomor syscall hanyalah indeks dalam tabel dispatch loader. Loader mengeksekusi operasi yang diminta dan mengembalikan kata status `u64` (nol untuk sukses, bukan nol untuk kegagalan).

Sebagai contoh, `sol_invoke_signed` mengemas instruksi, daftar akunnya, dan seed penandatangan PDA, menyerahkannya ke loader, dan loader melakukan CPI dengan otoritas yang tepat seperti ini:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Kode Vault" id="the-vault-code" level="h2" />

Sekarang setelah kita membongkar setiap blok pembangun program Solana "tanpa crate", kita dapat menguraikan vault itu sendiri. Ingat, vault melakukan persis dua hal:
- **Deposit** lamport ke dalam PDA yang berasal dari kunci publik pemilik.
- **Withdraw** lamport yang sama nanti; hanya oleh pemilik.

Setiap instruksi akan membawa tiga akun:
- **Owner** (penandatangan, dapat ditulis): Pengguna yang menyetor atau menarik dana.
- **Vault** (dapat ditulis): PDA tempat semua lamport disimpan.
- **System Program**: akun yang diperlukan untuk melakukan transfer lamport.

Sebelum memulai, kita perlu membuat proyek baru, untuk melakukannya jalankan perintah ini di terminal Anda:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

Dalam `Cargo.toml` tambahkan:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Template 

Semuanya akan berada di `lib.rs`. Secara sekilas, file akan berisi Syscall Shims (struct kecil, #[repr(C)] yang mencerminkan tata letak syscall mentah yang kita butuhkan), dan offset data sebagai konstanta (untuk memudahkan bekerja dengan data mentah).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Pemeriksaan Akun

Sebelum kita dapat menjalankan `deposit` atau `withdraw`, entrypoint harus memastikan transaksi memberikan kita akun yang tepat dan masing-masing memiliki flag yang diharapkan.

Karena kita bekerja pada level pointer mentah, setiap pemeriksaan dilakukan dengan perhitungan pointer sederhana dan pemuatan langsung.

Delapan byte pertama dari catatan input menyimpan account_len. Untuk vault ini kita memerlukan tiga akun: pemilik, vault PDA, dan System Program:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Kita melanjutkan dengan memeriksa setiap akun, offset tata letak yang kita definisikan sebelumnya memungkinkan kita memeriksa setiap flag tanpa melakukan deserialisasi struktur lengkap.

Untuk akun pertama, penandatangan, ini adalah pemeriksaan yang kita lakukan: 
- Harus unik (is_duplicate == 0xff)
- Dapat ditulis (kita akan mengubah lamports-nya)
- Penandatangan
- Tidak dapat dieksekusi
- Tidak boleh memiliki data 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Kita juga menyimpan kunci publik pemilik untuk pemeriksaan PDA nanti:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Untuk akun kedua, vault, ini adalah pemeriksaan yang kita lakukan:
- Dapat ditulis (kita akan mengubah lamports-nya)
- Dimiliki oleh System Program
- Panjang data harus nol (kita tidak menyimpan state di sini)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Kita juga mengambil kunci publik vault untuk pemeriksaan PDA nanti:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Untuk akun terakhir, system program, ini adalah pemeriksaan yang kita lakukan: 
- Harus dapat dieksekusi
- Kuncinya harus sama dengan SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Pemeriksaan instruksi

Setelah validasi akun, akhirnya kita dapat mengurai payload instruksi. Dan kita menggunakan pendekatan yang sama seperti program native dengan menggunakan byte pertama sebagai diskriminator:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

Dari sini kita bercabang ke handler deposit atau withdraw, dengan keyakinan bahwa setiap akun dan flag adalah tepat seperti yang diharapkan vault.

#### Logika Deposit

Kita akan mulai dengan penjelasan yang lebih rinci tentang instruksi deposit. Semua pemeriksaan berada di bagian depan; setelah lolos, kita membuat transfer System-Program dan menjalankannya.

Data instruksi dari instruksi ini terlihat seperti ini:
- Byte 0 adalah diskriminator (`0x00` untuk deposit).
- Byte 1 adalah bump yang akan Anda gunakan kembali untuk pemeriksaan PDA.
- Byte 2-9 berisi jumlah lamport dalam little-endian yang akan diperiksa dan ditolak jika jumlahnya 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Setelah itu kita melakukan hash pada kunci pemilik menggunakan syscall `sol_sha256`, dengan bump, ID program dan string unik "ProgramDerivedAddress". 

Kita membandingkan hasilnya dengan kunci vault yang kita simpan selama pemeriksaan akun. Jika berbeda, akan mengembalikan `InvalidSeeds`.

Jika berbeda, akan mengembalikan `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Terakhir, akhirnya kita dapat membuat transfer System-Program. 

System Program menggunakan diskriminator empat byte (untuk transfer nilainya adalah 2) dan memerlukan 8 byte tambahan yang mewakili jumlah yang ingin kita transfer dari `from_account` ke `to_account`

Kemudian kita perlu membangun array kecil dari dua nilai SolAccountMeta: from = owner (penandatangan, dapat ditulis), to = vault (dapat ditulis). Kita menggabungkannya dengan `instruction_data` untuk membuat struktur `SolInstruction`:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Tetapi sebelum memanggil syscall `sol_invoke_signed_c` kita perlu membangun dua struktur `SolAccountInfo`, satu untuk pemilik dan satu untuk
vault yang menyediakan pointer ke saldo lamport mereka dan irisan data tepat di tempat loader meninggalkannya di memori.

Setelah itu kita dapat memanggil syscall dengan meneruskan pointer instruksi, pointer ke array `SolAccountInfo` dua elemen Anda, dan jumlah akun (2). Karena transaksi luar sudah ditandatangani oleh pemilik, tidak diperlukan seed PDA di sini, jadi argumen `signers_seeds_addr` adalah NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Logika Penarikan

Instruksi penarikan mirip dengan deposit, tetapi dengan beberapa perbedaan kunci. Data instruksinya lebih sederhana:
- Byte 0 adalah diskriminator (`0x01` untuk penarikan).
- Byte 1 adalah bump yang akan Anda gunakan kembali untuk pemeriksaan PDA.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Kita melakukan pemeriksaan PDA yang sama seperti pada deposit, menggunakan kunci publik pemilik, bump, ID program, dan string unik "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Perbedaan utama dalam penarikan adalah kita perlu menandatangani transaksi dengan PDA itu sendiri. Untuk melakukan ini, kita perlu menyediakan seeds yang digunakan untuk menurunkan PDA. Kita membuat array `SolSignerSeedsC` dengan dua elemen:
- Kunci publik pemilik (32 byte)
- Bump (1 byte)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Kemudian kita menyusun instruksi transfer Program Sistem, tetapi kali ini dari vault ke pemilik. Data instruksinya sama dengan deposit:
- Diskriminator empat-byte (nilai 2 untuk transfer)
- Delapan byte untuk jumlah (yang kita dapatkan dari lamports vault)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Akun meta dibalik dibandingkan dengan deposit:
- Akun pertama adalah vault (dapat ditulis, penandatangan)
- Akun kedua adalah pemilik (dapat ditulis)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Akhirnya, kita memanggil `sol_invoke_signed_c` dengan instruksi, informasi akun, dan seeds penandatangan yang kita buat sebelumnya:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Penutup" id="closing-remarks" level="h2" />

Meskipun pendekatan tingkat rendah untuk menulis program Solana ini mungkin tampak ekstrem, ini memiliki tujuan pendidikan yang penting. Kami tidak menyarankan Anda menulis program Anda dengan cara ini; sebenarnya, kami sangat merekomendasikan menggunakan framework dan crate yang sudah mapan yang mengabstraksikan kompleksitas ini. Namun, memahami mekanisme yang mendasarinya sangat berharga.

Setiap abstraksi yang kita gunakan dalam pengembangan Solana, baik itu `solana_program`, `anchor`, atau framework lainnya, dibangun di atas blok-blok dasar yang fundamental ini. Dengan membuka lapisan-lapisan dan memeriksa mekanisme dasarnya, kita mendapatkan pemahaman yang lebih dalam tentang:

1. Bagaimana runtime Solana berinteraksi dengan program kita
2. Mengapa keputusan desain tertentu dibuat dalam framework tingkat yang lebih tinggi
3. Di mana potensi optimasi mungkin ada
4. Bagaimana cara men-debug masalah dengan lebih baik ketika terjadi

Pengetahuan ini tidak hanya bersifat akademis; ini praktis. Ketika Anda memahami fondasinya, Anda dapat:
- Menulis program yang lebih efisien dengan membuat keputusan yang tepat tentang struktur data dan penggunaan memori
- Mendiagnosis dan memperbaiki masalah dengan lebih baik ketika muncul
- Berkontribusi pada ekosistem dengan meningkatkan alat-alat yang kita semua gunakan
- Membuat keputusan yang tepat tentang kapan menggunakan abstraksi tertentu dan kapan bekerja lebih dekat dengan level dasar

Ingat, tujuan dari latihan ini bukanlah untuk mengajarkan Anda cara menulis program tanpa crates, tetapi untuk membantu Anda memahami apa yang dilakukan crates tersebut di balik layar. Pemahaman ini adalah langkah pertama menuju penulisan program Solana yang lebih baik dan lebih efisien, terlepas dari alat mana yang Anda pilih untuk digunakan.
