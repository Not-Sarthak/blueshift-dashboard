import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Le point d'entrée 

Le `entrypoint!()` est le symbole unique que chaque programme Solana doit exposer. C'est le point de transfert où le runtime Solana passe du chargeur à votre code.

Avant le saut, le chargeur regroupe tout ce dont une instruction a besoin dans un enregistrement plat de style C stocké sur la page d'entrée de la VM BPF. La macro décompresse ensuite cet enregistrement et transmet à votre Rust trois tranches et références sécurisées :
- **program_id** : la clé publique du programme en cours d'exécution.
- **accounts** : un pointeur vers un tableau contigu d'enregistrements AccountInfo, plus une longueur.
- **instruction_data** : une tranche pointeur-plus-longueur d'octets bruts fournis par la transaction.

La macro va :
- Convertir ces pointeurs bruts en tranches Rust sécurisées.
- Capturer les paniques pour qu'elles deviennent des codes `ProgramError::Custom` propres au lieu de faire planter la VM.
- Transmettre tout à une fonction définie par l'utilisateur (souvent appelée `process_instruction`) qui renvoie un `ProgramResult`.

Voici une description de l'enregistrement unique et plat que le chargeur Solana place dans la page d'entrée de la VM BPF avant de sauter vers votre point d'entrée.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len` : nombre de comptes envoyés.
- `account_info` : les enregistrements de compte bruts dans l'instruction, l'un après l'autre.
- `instruction_len` : combien d'octets de données d'instruction suivent.
- `instruction_data` : l'instruction elle-même
- `program_id` : les 32 octets du `Pubkey` du programme en cours d'exécution.

Chaque élément du tableau `account_info` suit ensuite la même disposition compacte :

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate` : assurez-vous de ne pas "redésérialiser" les données si le même compte apparaît plus d'une fois dans la liste en le sautant. `0xFF` signifie "unique" ; toute autre valeur est l'index qu'il copie.
- `is_signer` / `is_writable` / `executable` : drapeaux d'un octet que le runtime utilise pour que votre programme puisse contrôler la logique et les CPI sans appels système supplémentaires.
- `alignment` : un emplacement de quatre octets qui maintient toute la structure alignée sur 8 octets. Pinocchio le réutilise pour suivre la longueur des données originales pendant les réallocations.
- `key` / `owner` / `lamports` : les données minimales viables que chaque compte devrait avoir.
- `data_len` + `data` : les données de longueur variable que le compte pourrait avoir.
- `padding` : le chargeur préalloue 10 240 octets, la taille maximale d'un compte, afin que les données du compte puissent changer et croître sur place sans déplacer la mémoire.
- `align_padding` : remplissage supplémentaire, si nécessaire, pour que le prochain `AccountRaw` commence toujours sur une limite de 8 octets (important pour certains hôtes eBPF).
- `rent_epoch` : époque à laquelle le compte doit payer le loyer suivant ; conservé pour la compatibilité même si la collecte des loyers est en pause.
