import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Der Einstiegspunkt

Der `entrypoint!()` ist das einzige Symbol, das jedes Solana-Programm bereitstellen muss. Es ist der Übergabepunkt, an dem die Solana-Laufzeit vom Loader in deinen Code springt.

Vor dem Sprung packt der Loader alles, was eine Anweisung benötigt, in einen flachen, C-ähnlichen Datensatz, der auf der Eingabeseite der BPF-VM gespeichert wird. Das Makro entpackt dann diesen Datensatz und übergibt deinem Rust-Code drei sichere Slices und Referenzen:
- **program_id**: der Public Key des Programms, das gerade ausgeführt wird.
- **accounts**: ein Zeiger auf ein zusammenhängendes Array von AccountInfo-Datensätzen sowie eine Längenangabe.
- **instruction_data**: ein Zeiger-plus-Länge-Slice von Rohbytes, die von der Transaktion bereitgestellt werden.

Das Makro wird:
- Diese Rohzeiger in sichere Rust-Slices umwandeln.
- Panics abfangen, damit sie zu sauberen `ProgramError::Custom`Codes werden, anstatt die VM zum Absturz zu bringen.
- Alles an eine benutzerdefinierte Funktion (oft genannt `process_instruction`) weiterleiten, die ein `ProgramResult` zurückgibt.

Hier ist eine Beschreibung des einzelnen, flachen Datensatzes, den der Solana-Loader auf der Eingabeseite der BPF-VM platziert, bevor er zu deinem Einstiegspunkt springt.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`: Anzahl der gesendeten Konten.
- `account_info`: die Roh-Kontodatensätze in der Anweisung, einer nach dem anderen.
- `instruction_len`: wie viele Bytes an Anweisungsdaten folgen.
- `instruction_data`: die Anweisung selbst
- `program_id`: die 32-Byte `Pubkey` des ausgeführten Programms.

Jedes Element des `account_info`Arrays folgt dann demselben gepackten Layout:

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`: stelle sicher, dass die Daten nicht "neu deserialisiert" werden, wenn dasselbe Konto mehr als einmal in der Liste erscheint, indem du es überspringst. `0xFF` bedeutet "einzigartig"; jeder andere Wert ist der Index, den es kopiert.
- `is_signer` / `is_writable` / `executable`: Einzelbyte-Flags, die die Laufzeit verwendet, damit dein Programm Logik und CPIs steuern kann, ohne zusätzliche Syscalls zu benötigen.
- `alignment`: Ein Platzhalter-Vier-Byte-Slot, der die gesamte Struktur 8-Byte-ausgerichtet hält. Pinocchio verwendet ihn, um die ursprüngliche Datenlänge während Reallocs zu verfolgen.
- `key` / `owner` / `lamports`: Die minimal notwendigen Daten, die jedes Konto haben sollte.
- `data_len` + `data`: Die Daten variabler Länge, die das Konto haben könnte.
- `padding`: Der Loader reserviert vorab 10.240 Bytes, die maximale Größe eines Kontos, damit die Kontodaten sich ändern und wachsen können, ohne den Speicher zu verschieben.
- `align_padding`: Zusätzliche Füllbytes, falls erforderlich, damit das nächste `AccountRaw` immer noch an einer 8-Byte-Grenze beginnt (wichtig für einige eBPF-Hosts).
- `rent_epoch`: Epoche, in der das Konto als nächstes Miete zahlen muss; wird aus Kompatibilitätsgründen beibehalten, obwohl die Mieteinziehung pausiert ist.
