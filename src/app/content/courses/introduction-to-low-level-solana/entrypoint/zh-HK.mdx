import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 入口點

`entrypoint!()` 是每個 Solana 程式必須公開的唯一符號。這是 Solana 執行環境從加載器跳轉到您的程式碼的交接點。

在跳轉之前，加載器會將指令所需的一切打包成一個平坦的 C 樣式記錄，存儲在 BPF VM 的輸入頁面上。然後，宏會解包該記錄並將其交給您的 Rust 程式，提供三個安全的切片和引用：
- **program_id**：當前執行的程式的公鑰。
- **accounts**：指向 AccountInfo 記錄的連續數組的指針，以及其長度。
- **instruction_data**：由交易提供的原始位元組的指針加長度切片。

該宏將：
- 將這些原始指針轉換為安全的 Rust 切片。
- 捕獲異常，將其轉換為乾淨的 `ProgramError::Custom` 錯誤碼，而不是使 VM 崩潰。
- 將所有內容轉發到用戶定義的函數（通常稱為 `process_instruction`），該函數返回 `ProgramResult`。

以下是 Solana 加載器在跳轉到您的入口點之前，放置在 BPF VM 的輸入頁面上的單一平坦記錄的描述。

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`：傳入的帳戶數量。
- `account_info`：指令中的原始帳戶記錄，一個接一個。
- `instruction_len`：後續指令數據的位元組數量。
- `instruction_data`：指令本身。
- `program_id`：正在運行的程式的 32 位元 `Pubkey`。

`account_info` 陣列的每個元素都遵循相同的打包佈局：

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`：如果同一帳戶在列表中多次出現，請跳過它以確保不會重新反序列化數據。`0xFF` 表示“唯一”；任何其他值則是其複製的索引。
- `is_signer` / `is_writable` / `executable`：執行環境使用的單位元標誌，使您的程式能夠在不需要額外系統調用的情況下控制邏輯和 CPI。
- `alignment`：一個佔位的四位元組槽，保持整個結構 8 位元組對齊。Pinocchio 在重新分配期間將其重新用於跟蹤原始數據長度。
- `key` / `owner` / `lamports`：每個帳戶應具有的最低可行數據。
- `data_len` + `data`：帳戶可能具有的可變長度數據。
- `padding`：加載器預先分配 10,240 位元組，這是帳戶的最大大小，因此帳戶數據可以在不移動記憶體的情況下進行更改和增長。
- `align_padding`：如果需要，額外的填充，以便下一個 `AccountRaw` 仍然從 8 位元組邊界開始（對某些 eBPF 主機很重要）。
- `rent_epoch`：帳戶下一次必須支付租金的時代；為了兼容性而保留，即使租金收取已暫停。
