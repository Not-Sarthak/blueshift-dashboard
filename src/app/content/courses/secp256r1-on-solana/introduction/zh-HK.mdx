import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Solana 上的 Secp256r1

![Solana 上的 Secp256r1](/graphics/course-banners/secp256r1-on-solana.png)

Secp256r1 是現代密碼學中最廣泛採用的橢圓曲線之一，支援從 TLS 連接到硬件安全密鑰的各種應用。這條曲線構成了無數應用程式中數字安全的基石。

由 [Orion](https://x.com/BasedOrion_) 在 [SIMD 75](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0075-precompile-for-secp256r1-sigverify.md) 中提出的 secp256r1 預編譯功能閘，已於 Solana 的區塊 800 啟用。

<ArticleSection name="什麼是 Secp256r1" id="what-is-secp256r1" level="h2" />

我們所知的 secp256r1 是由高效密碼學標準組織（SECG）在 2000 年代初期標準化的。命名規則告訴了我們一切需要知道的資訊：
- `sec`：高效密碼學標準
- `p`：該曲線定義於素數域上
- `256`：素數模數約為 2^256
- `r`：隨機曲線（與 Koblitz 曲線相對）
- `1`：此類別中的第一條曲線

Secp256r1 後來被 NIST 採用為 P-256，並成為 FIPS 186-2 的一部分。SECG 和 NIST 的雙重標準化賦予了該曲線廣泛的合法性，並促使其被眾多協議和應用採用——使其成為全球生產系統中最經得起考驗的曲線之一。

<ArticleSection name="數學基礎" id="mathematical-foundations" level="h2" />

### 素數域與有限算術

要理解 secp256r1，我們必須首先掌握在有限域中運算的概念。與普通算術中數字可以無限增長不同，橢圓曲線密碼學在一個有限的數學空間中運作。

該曲線在素數域 𝔽p 上運行，其中：`p = 2^256 - 2^224 + 2^192 + 2^96 - 1`。

這不僅僅是任何隨機的 256 位素數；它被稱為偽梅森素數。梅森素數的形式為 `2^n - 1`，這允許使用位移和減法進行極快的模數約簡，而不需要昂貴的除法操作。偽梅森素數將這一概念擴展到“接近”2 的冪的數字，保持了大部分計算優勢，同時增加了額外的安全屬性。

對於 secp256r1 的質數，我們可以將其重寫為：`p = 2^256 - c`，其中 `c = 2^224 - 2^192 - 2^96 + 1`

這種結構意味著當我們需要對數字 `mod p` 進行約簡時（這在橢圓曲線操作中經常發生），我們可以使用快速約簡算法，而不是緩慢的通用除法。

> 這使得 secp256r1 的操作比使用任意質數的曲線快得多：對於像 TLS 握手和硬件安全模組這樣對性能要求極高的應用來說，這是一個關鍵優勢。

### 橢圓曲線方程

Secp256r1 遵循橢圓曲線的短 Weierstrass 形式：`y² = x³ + ax + b (mod p)`

對於 secp256r1，其參數為：
- `a = -3`（或等價於 p-3）
- `b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b`

> `a = -3` 並不是一個任意數字，而是能夠在點加法和倍點操作中實現顯著優化，減少所需的域乘法次數。

每個橢圓曲線加密系統都需要一個具有已知階的生成點 G。對於 secp256r1：

```
G = (Gx, Gy) where:
Gx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
Gy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
```

> 這些值是通過“可驗證隨機”過程生成的，以確保沒有隱藏的後門。如果曲線設計者可以隨意選擇參數，他們可能會選擇包含只有他們知道的秘密數學關係的參數，從而創建後門，危及使用該曲線的所有系統。

### 曲線階與安全等級

**曲線階 (n)** 表示橢圓曲線上所有點的總數，包括無窮遠點：`n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551`

曲線階決定了私鑰空間的大小，並直接影響安全性。儘管被稱為“256 位”，secp256r1 實際上提供大約 128 位的安全性，而不是 256 位。這是因為針對橢圓曲線離散對數問題的最佳已知攻擊的複雜度大約為 `√n`，這意味著階為 `~2^256` 的曲線提供 `~2^128` 的安全性。

**cofactor (h)** 是 1，這意味著 secp256r1 是一條素數階曲線。這一點很重要，因為：
- 每個非單位點的階都是相同的 n
- 不會出現小子群攻擊
- 實現更加簡化，因為我們不需要擔心低階點

### 標量域

雖然曲線本身是定義在坐標域 𝔽p 上，但私鑰存在於另一個數學空間：標量域 𝔽n，其中 n 是曲線的階。

```
Private key ∈ [1, n-1]
Public key = private_key × G (scalar multiplication)
```

這一區別至關重要，因為：
- 私鑰是標量（整數 `mod n`）
- 曲線坐標是域元素（整數 `mod p`）
- 它們有不同的模數：`n ≠ p`

在生成私鑰時，我們從 `[1, n-1]` 中均勻取樣，而不是從 `[1, p-1]` 中取樣。這確保了每個私鑰都對應於有效的標量乘法操作，並防止某些數學攻擊。

<ArticleSection name="為什麼 Secp256r1 佔主導地位" id="why-secp256r1-dominates" level="h2" />

儘管存在像 Curve25519 這樣可能更優越的曲線，secp256r1 通過早期標準化、監管批准和廣泛的硬件優化實現了普遍採用。

與可能在數學上更優越的新曲線不同，secp256r1 代表了現實世界系統所需的密碼學強度、實現效率和生態系統兼容性之間的最佳平衡。

一旦硬件製造商、操作系統和安全標準都聚焦於 secp256r1，切換成本就變得難以承受。

我們探討的特定數學特性（偽梅森素數、a = -3 優化和可驗證參數生成）使得從智能手機安全元件到高性能服務器的實現都得到了高度優化。

這種硬件生態系統效應創造了一個自我強化的採用循環。

<ArticleSection name="Solana 上的 Secp256r1" id="secp256r1-on-solana" level="h2" />

Solana 通過其內置的預編譯功能，提供對 secp256r1 簽名驗證的原生支持，這是由 [Orion](https://x.com/BasedOrion_) 通過 [SIMD-0075](https://github.com/solana-foundation/solana-improvement-documents/pull/75) 引入的。

這個預編譯功能使得在 Solana 上實現現代身份驗證方法（如通行密鑰）成為可能，因為 secp256r1 是 WebAuthn 和通行密鑰實現所使用的相同橢圓曲線。

我們詳細介紹的數學特性，特別是優化的域算術和標準化參數，使 secp256r1 成為硬件安全模塊和支持這些身份驗證系統的安全區域的通用選擇。

### 銜接 Web2 和 Web3 的身份驗證

傳統錢包的啟用過程中，因為助記詞要求用戶達到完美的安全標準，導致 60-80% 的用戶流失率。用戶需要記住 12-24 個隨機單詞，永久安全地存儲它們，並且永遠不會成為網絡釣魚的受害者——這對於主流採用來說是一個不可能的標準。

現代身份驗證方法（如通行密鑰）通過將私鑰移入專用的安全硬件中，消除了人為錯誤。

然而，這些系統標準化使用 secp256r1 是因為我們探討的特定數學和實現優勢：
- **硬件兼容性：** 偽梅森素數使得在受限的安全元件環境中高效實現成為可能
- **法規合規性：** NIST 標準化允許其用於政府和企業的安全需求
- **跨平台一致性：** 可驗證的隨機參數確保相同的曲線在所有硬件製造商中以相同方式運作

通過原生支持 secp256r1，Solana 開發者現在可以構建利用現有硬件安全基礎設施的應用程序，通過熟悉的身份驗證方法實現無縫啟用，同時保持這條曲線特定數學特性所帶來的重要安全保證。