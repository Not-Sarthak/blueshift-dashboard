import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Solana 上的 Secp256r1

![Solana 上的 Secp256r1](/graphics/course-banners/secp256r1-on-solana.png)

Secp256r1 是现代密码学中最广泛采用的椭圆曲线之一，支持从 TLS 连接到硬件安全密钥的各种应用。这条曲线构成了无数应用中数字安全的基础。

由 [Orion](https://x.com/BasedOrion_) 在 [SIMD 75](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0075-precompile-for-secp256r1-sigverify.md) 中提出的 secp256r1 预编译功能门控，在 Solana 的区块 800 上被激活。

<ArticleSection name="什么是 Secp256r1" id="what-is-secp256r1" level="h2" />

我们所熟知的 secp256r1 曲线由高效密码学标准组织（SECG）在 2000 年代初期标准化。它的命名规则告诉了我们关于它的一切：
- `sec`：高效密码学标准
- `p`：曲线定义在一个素数域上
- `256`：素数模数大约为 2^256
- `r`：随机曲线（与 Koblitz 曲线相对）
- `1`：此类别中的第一条曲线

Secp256r1 后来被 NIST 采用为 P-256，并成为 FIPS 186-2 的一部分。SECG 和 NIST 的双重标准化赋予了这条曲线广泛的合法性，并促使其被众多协议和应用采用——使其成为全球生产系统中最经受考验的曲线之一。

<ArticleSection name="数学基础" id="mathematical-foundations" level="h2" />

### 素数域与有限算术

要理解 secp256r1，我们首先需要掌握在有限域中工作的概念。与普通算术中数字可以无限增长不同，椭圆曲线密码学在一个有限的数学空间中运作。

该曲线在素数域 𝔽p 上运作，其中：`p = 2^256 - 2^224 + 2^192 + 2^96 - 1`。

这不仅仅是任意的 256 位素数；它被称为伪梅森素数。梅森素数的形式为 `2^n - 1`，这允许使用位移和减法而非昂贵的除法操作来实现极快的模约简。伪梅森素数将这一概念扩展到“接近”2 的幂的数字，在保持计算优势的同时增加了额外的安全属性。

对于 secp256r1 的素数，我们可以将其重写为：`p = 2^256 - c`，其中 `c = 2^224 - 2^192 - 2^96 + 1`

这种结构意味着，当我们需要对数字 `mod p` 进行约简时（这在椭圆曲线操作中经常发生），可以使用快速约简算法，而不是缓慢的通用除法。

> 这使得 secp256r1 的操作比使用任意素数的曲线快得多：对于像 TLS 握手和硬件安全模块这样的性能关键型应用，这是一个至关重要的优势。

### 椭圆曲线方程

Secp256r1 遵循椭圆曲线的短 Weierstrass 形式：`y² = x³ + ax + b (mod p)`

对于 secp256r1，其参数为：
- `a = -3`（或等价于 p-3）
- `b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b`

> `a = -3` 并不是一个任意数字，而是能够显著优化点加法和倍点操作，减少所需的域乘法次数。

每个椭圆曲线加密系统都需要一个具有已知阶的生成点 G。对于 secp256r1：

```
G = (Gx, Gy) where:
Gx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
Gy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
```

> 这些值是通过“可验证的随机”过程生成的，以确保没有隐藏的后门。如果曲线设计者可以随意选择参数，他们可能会选择包含只有他们知道的秘密数学关系的参数，从而创建后门，危及使用该曲线的所有系统。

### 曲线阶与安全级别

**曲线阶 (n)** 表示椭圆曲线上点的总数，包括无穷远点：`n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551`

曲线阶决定了私钥空间的大小，并直接影响安全性。尽管被称为“256 位”，但 secp256r1 实际上提供大约 128 位的安全性，而不是 256 位。这是因为针对椭圆曲线离散对数问题的已知最佳攻击的复杂度大约为 `√n`，这意味着阶为 `~2^256` 的曲线提供 `~2^128` 的安全性。

**余因子 (h)** 为 1，这意味着 secp256r1 是一个素数阶曲线。这一点很重要，因为：
- 每个非单位点的阶都是相同的 n
- 不存在小子群攻击的可能性
- 实现更加简化，因为我们不需要担心低阶点的问题

### 标量域

虽然曲线本身定义在坐标域 𝔽p 上，但私钥存在于另一个数学空间：标量域 𝔽n，其中 n 是曲线的阶。

```
Private key ∈ [1, n-1]
Public key = private_key × G (scalar multiplication)
```

这种区分至关重要，因为：
- 私钥是标量（整数 `mod n`）
- 曲线坐标是域元素（整数 `mod p`）
- 它们有不同的模数：`n ≠ p`

在生成私钥时，我们从 `[1, n-1]` 中均匀采样，而不是从 `[1, p-1]` 中采样。这确保了每个私钥都对应一个有效的标量乘法操作，并防止某些数学攻击。

<ArticleSection name="为什么 Secp256r1 占主导地位" id="why-secp256r1-dominates" level="h2" />

尽管存在像 Curve25519 这样可能更优的曲线，secp256r1 通过早期标准化、监管批准和广泛的硬件优化实现了普遍采用。

与可能在数学上更优的新曲线不同，secp256r1 代表了现实系统所需的密码强度、实现效率和生态系统兼容性的最佳平衡。

一旦硬件制造商、操作系统和安全标准都聚焦于 secp256r1，切换成本就变得难以承受。

我们探讨的特定数学属性（伪梅森素数、a = -3 优化和可验证参数生成）使得从智能手机安全元件到高性能服务器的实现都得到了高度优化。

这种硬件生态系统效应创造了一个自我强化的采用循环。

<ArticleSection name="Solana 上的 Secp256r1" id="secp256r1-on-solana" level="h2" />

Solana通过其内置的预编译功能提供对secp256r1签名验证的原生支持，该功能由[Orion](https://x.com/BasedOrion_)通过[SIMD-0075](https://github.com/solana-foundation/solana-improvement-documents/pull/75)引入。

这一预编译功能使得在Solana上实现现代认证方法（如通行密钥）成为可能，因为secp256r1是WebAuthn和通行密钥实现所使用的相同椭圆曲线。

我们详细介绍的数学特性，特别是优化的域算术和标准化参数，使得secp256r1成为硬件安全模块和支持这些认证系统的安全隔离区的通用选择。

### 架起Web2与Web3认证的桥梁

传统钱包的注册流程因助记词的复杂性导致60-80%的用户流失率。用户必须记住12-24个随机单词，永久安全地存储它们，并避免钓鱼攻击——这对主流用户来说是一个不可能完成的任务。

现代认证方法（如通行密钥）通过将私钥移入专用的安全硬件中，消除了人为错误。

然而，这些系统选择标准化使用secp256r1是因为我们探讨的特定数学和实现优势：
- **硬件兼容性：**伪梅森素数使得在受限的安全元件环境中实现高效
- **法规合规性：**NIST标准化允许其用于政府和企业的安全需求
- **跨平台一致性：**可验证的随机参数确保相同的曲线在所有硬件制造商中表现一致

通过对secp256r1的原生支持，Solana开发者现在可以构建利用现有硬件安全基础设施的应用程序，从而通过熟悉的认证方法实现无缝注册，同时保持这一曲线特定数学特性的安全保障的重要性。