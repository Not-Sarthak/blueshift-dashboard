import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Secp256r1 auf Solana

![Secp256r1 auf Solana](/graphics/course-banners/secp256r1-on-solana.png)

Secp256r1 ist eine der am weitesten verbreiteten elliptischen Kurven in der modernen Kryptographie und bildet die Grundlage f√ºr alles von TLS-Verbindungen bis hin zu Hardware-Sicherheitsschl√ºsseln. Diese Kurve bildet das R√ºckgrat der digitalen Sicherheit in unz√§hligen Anwendungen.

Das Secp256r1-Precompile-Feature-Gate, vorgeschlagen von [Orion](https://x.com/BasedOrion_) in [SIMD 75](https://github.com/solana-foundation/solana-improvement-documents/blob/main/proposals/0075-precompile-for-secp256r1-sigverify.md), wurde auf Solana bei Block 800 aktiviert.

<ArticleSection name="Was ist Secp256r1" id="what-is-secp256r1" level="h2" />

Die Kurve, die wir als Secp256r1 kennen, wurde Anfang der 2000er Jahre von der Standards for Efficient Cryptography Group (SECG) standardisiert. Die Namenskonvention verr√§t uns alles, was wir wissen m√ºssen:
- `sec`: Standards for Efficient Cryptography
- `p`: Die Kurve ist √ºber einem Primzahlk√∂rper definiert
- `256`: Der Primzahlmodul ist ungef√§hr 2^256
- `r`: Zuf√§llige Kurve (im Gegensatz zu Koblitz-Kurven)
- `1`: Die erste Kurve in dieser Kategorie

Secp256r1 wurde sp√§ter vom NIST als P-256 √ºbernommen und wurde Teil von FIPS 186-2. Diese doppelte Standardisierung durch sowohl SECG als auch NIST verlieh der Kurve weitreichende Legitimit√§t und f√ºhrte zu ihrer Einf√ºhrung in zahlreichen Protokollen und Anwendungen ‚Äì was sie zu einer der am besten erprobten Kurven in Produktionssystemen weltweit macht.

<ArticleSection name="Mathematische Grundlagen" id="mathematical-foundations" level="h2" />

### Primzahlk√∂rper und endliche Arithmetik

Um Secp256r1 zu verstehen, m√ºssen wir zun√§chst das Konzept der Arbeit in endlichen K√∂rpern erfassen. Im Gegensatz zur regul√§ren Arithmetik, bei der Zahlen unendlich wachsen k√∂nnen, operiert die Kryptographie mit elliptischen Kurven in einem begrenzten mathematischen Raum.

Die Kurve operiert √ºber dem Primzahlk√∂rper ùîΩp, wobei: `p = 2^256 - 2^224 + 2^192 + 2^96 - 1`.

Dies ist nicht irgendeine zuf√§llige 256-Bit-Primzahl; es handelt sich um eine sogenannte Pseudo-Mersenne-Primzahl. Mersenne-Primzahlen haben die Form `2^n - 1`, was eine extrem schnelle modulare Reduktion mittels Bit-Verschiebungen und Subtraktionen anstelle von teuren Divisionsoperationen erm√∂glicht. Pseudo-Mersenne-Primzahlen erweitern dieses Konzept auf Zahlen, die "nahe" an Potenzen von 2 liegen, und behalten dabei viel vom rechnerischen Vorteil bei, w√§hrend sie zus√§tzliche Sicherheitseigenschaften hinzuf√ºgen.

F√ºr die Primzahl von secp256r1 k√∂nnen wir sie umschreiben als: `p = 2^256 - c`, wobei `c = 2^224 - 2^192 - 2^96 + 1`

Diese Struktur bedeutet, dass wir bei der Reduzierung einer Zahl `mod p` (was bei Operationen mit elliptischen Kurven st√§ndig vorkommt) schnelle Reduktionsalgorithmen anstelle von langsamen Divisionsverfahren f√ºr allgemeine Zwecke verwenden k√∂nnen.

> Dies macht secp256r1-Operationen deutlich schneller als Kurven mit beliebigen Primzahlen: ein entscheidender Vorteil f√ºr leistungskritische Anwendungen wie TLS-Handshakes und Hardware-Sicherheitsmodule.

### Die Gleichung der elliptischen Kurve

Secp256r1 folgt der kurzen Weierstrass-Form einer elliptischen Kurve: `y¬≤ = x¬≥ + ax + b (mod p)`

F√ºr secp256r1 sind die Parameter:
- `a = -3` (oder √§quivalent, p-3)
- `b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b`

> `a = -3` ist keine willk√ºrliche Zahl, sondern erm√∂glicht erhebliche Optimierungen bei Punktadditions- und Verdopplungsoperationen, wodurch die Anzahl der erforderlichen Feldmultiplikationen reduziert wird.
 
Jedes Kryptosystem mit elliptischen Kurven ben√∂tigt einen Generatorpunkt G mit bekannter Ordnung. F√ºr secp256r1:

```
G = (Gx, Gy) where:
Gx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
Gy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
```

> Diese Werte wurden durch einen "nachweisbar zuf√§lligen" Prozess generiert, um sicherzustellen, dass keine versteckten Hintert√ºren vorhanden sind. Wenn Kurvendesigner einfach beliebige Werte ausw√§hlen k√∂nnten, k√∂nnten sie Parameter w√§hlen, die geheime mathematische Beziehungen enthalten, die nur sie kennen, wodurch Hintert√ºren entstehen w√ºrden, die jedes System, das die Kurve verwendet, kompromittieren w√ºrden.

### Kurvenordnung und Sicherheitsstufe

Die **Kurvenordnung (n)** repr√§sentiert die Gesamtzahl der Punkte auf der elliptischen Kurve, einschlie√ülich des Punktes im Unendlichen: `n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551`

Die Kurvenordnung bestimmt die Gr√∂√üe des privaten Schl√ºsselraums und beeinflusst direkt die Sicherheit. Obwohl sie als "256-Bit" bezeichnet wird, bietet secp256r1 tats√§chlich nur etwa 128 Bit Sicherheit, nicht 256 Bit. Dies liegt daran, dass die besten bekannten Angriffe gegen diskrete Logarithmusprobleme auf elliptischen Kurven eine Komplexit√§t von ungef√§hr `‚àön` haben, was bedeutet, dass eine Kurve mit der Ordnung `~2^256` eine Sicherheit von `~2^128` bietet.

Der **Kofaktor (h)** ist 1, was bedeutet, dass secp256r1 eine Kurve mit Primordnung ist. Dies ist wichtig, weil:
- Jeder Nicht-Identit√§tspunkt die gleiche Ordnung n hat
- Keine Small-Subgroup-Angriffe m√∂glich sind
- Die Implementierung vereinfacht wird, da wir uns keine Sorgen um Punkte niedriger Ordnung machen m√ºssen

### Das Skalarfeld

W√§hrend die Kurve selbst √ºber dem Koordinatenfeld ùîΩp definiert ist, befinden sich private Schl√ºssel in einem anderen mathematischen Raum: dem Skalarfeld ùîΩn, wobei n die Kurvenordnung ist.

```
Private key ‚àà [1, n-1]
Public key = private_key √ó G (scalar multiplication)
```

Diese Unterscheidung ist entscheidend, weil:
- Private Schl√ºssel Skalare sind (Ganzzahlen `mod n`)
- Kurvenkoordinaten Feldelemente sind (Ganzzahlen `mod p`)
- Dies unterschiedliche Moduli sind: `n ‚â† p`

Bei der Generierung privater Schl√ºssel nehmen wir eine gleichm√§√üige Stichprobe aus `[1, n-1]`, nicht aus `[1, p-1]`. Dies stellt sicher, dass jeder private Schl√ºssel einer g√ºltigen Skalarmultiplikationsoperation entspricht und verhindert bestimmte mathematische Angriffe.

<ArticleSection name="Warum Secp256r1 dominiert" id="why-secp256r1-dominates" level="h2" />

Trotz der Existenz potenziell √ºberlegener Kurven wie Curve25519 erreichte secp256r1 universelle Akzeptanz durch eine Kombination aus fr√ºher Standardisierung, beh√∂rdlicher Genehmigung und umfangreicher Hardware-Optimierung.

Im Gegensatz zu neueren Kurven, die mathematisch √ºberlegen sein k√∂nnten, repr√§sentiert secp256r1 die optimale Balance zwischen kryptografischer St√§rke, Implementierungseffizienz und √ñkosystem-Kompatibilit√§t, die reale Systeme ben√∂tigen.

Nachdem Hardwarehersteller, Betriebssysteme und Sicherheitsstandards alle auf secp256r1 konvergierten, wurden die Wechselkosten prohibitiv.

Die spezifischen mathematischen Eigenschaften, die wir untersucht haben (die Pseudo-Mersenne-Primzahl, die a = -3 Optimierung und die verifizierbare Parametergenerierung), erm√∂glichten hochoptimierte Implementierungen in allem, von Smartphone-Sicherheitselementen bis hin zu Hochleistungsservern.

Dieser Hardware-√ñkosystem-Effekt schuf einen selbstverst√§rkenden Zyklus der Adoption.

<ArticleSection name="Secp256r1 auf Solana" id="secp256r1-on-solana" level="h2" />

Solana bietet native Unterst√ºtzung f√ºr secp256r1-Signaturverifizierung durch seinen integrierten Precompile, der mit [SIMD-0075](https://github.com/solana-foundation/solana-improvement-documents/pull/75) von [Orion](https://x.com/BasedOrion_) eingef√ºhrt wurde.

Dieser Precompile erm√∂glicht moderne Authentifizierungsmethoden wie Passkeys auf Solana, da secp256r1 die gleiche elliptische Kurve ist, die von WebAuthn und Passkey-Implementierungen verwendet wird.

Die mathematischen Eigenschaften, die wir detailliert beschrieben haben, insbesondere die optimierte Feldarithmetik und standardisierten Parameter, machen secp256r1 zur universellen Wahl f√ºr Hardware-Sicherheitsmodule und Secure Enclaves, die diese Authentifizierungssysteme antreiben.

### Br√ºckenschlag zwischen Web2- und Web3-Authentifizierung

Traditionelles Wallet-Onboarding verzeichnet Nutzerabbruchraten von 60-80%, weil Seed-Phrasen perfekte Sicherheit von unvollkommenen Menschen verlangen. Nutzer m√ºssen 12-24 zuf√§llige W√∂rter auswendig lernen, sie f√ºr immer sicher aufbewahren und d√ºrfen niemals Opfer von Phishing werden ‚Äì ein unm√∂glicher Standard f√ºr die Mainstream-Adoption.

Moderne Authentifizierungsmethoden wie Passkeys eliminieren menschliche Fehler, indem sie private Schl√ºssel in dedizierte Sicherheitshardware verlagern.

 Diese Systeme haben sich jedoch auf secp256r1 standardisiert, aufgrund der spezifischen mathematischen und implementierungstechnischen Vorteile, die wir untersucht haben:
- **Hardware-Kompatibilit√§t:** Die Pseudo-Mersenne-Primzahl erm√∂glicht eine effiziente Implementierung in eingeschr√§nkten Secure-Element-Umgebungen
- **Regulatorische Konformit√§t:** Die NIST-Standardisierung erlaubt die Verwendung in staatlichen und Unternehmens-Sicherheitsanforderungen
- **Plattform√ºbergreifende Konsistenz:** Die nachweisbar zuf√§lligen Parameter stellen sicher, dass dieselbe Kurve bei allen Hardwareherstellern identisch funktioniert

Mit nativer secp256r1-Unterst√ºtzung k√∂nnen Solana-Entwickler jetzt Anwendungen erstellen, die bestehende Hardware-Sicherheitsinfrastruktur nutzen und ein nahtloses Onboarding durch vertraute Authentifizierungsmethoden erm√∂glichen, w√§hrend die Sicherheitsgarantien erhalten bleiben, die die spezifischen mathematischen Eigenschaften dieser Kurve so wichtig machen.