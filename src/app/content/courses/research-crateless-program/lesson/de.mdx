import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Byte für Byte: Die Anatomie eines Crateless-Programms

![Image Test](/graphics/banners/research-crateless-program.png)

Wenn du ein Solana-Programm geschrieben hast, hast du definitiv ein Crate wie `solana_program`, `pinocchio` oder ein Framework verwendet, das eines dieser Crates unter der Haube nutzt, wie `anchor`, `steel`...

Aber hast du dich jemals gefragt, was wir tun müssten, wenn diese Crates nicht existieren würden? Willkommen bei Low-Level 101, wo wir ein vollständig handgeschriebenes, Crate-loses Solana-Programm erstellen werden.

<ArticleSection name="Low-Level Solana 101" id="low-level-solana-101" level="h2" />

Bevor wir die Ärmel hochkrempeln und ein vollständiges Vault-Beispiel von Hand erstellen, müssen wir einige Grundlagen über Solana-Programme verstehen

#### `[repr(C)]` und `extern C`

Wenn du dir ein beliebiges Low-Level-Solana-Beispiel ansiehst, tauchen zwei Muster immer wieder auf:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

- `extern "C"` teilt dem Rust-Compiler mit, ein Symbol zu exponieren (oder zu erwarten), das der C-ABI folgt; die Aufrufkonvention, die definiert, welche eBPF-Register Argumente tragen, wie der Stack aufgebaut ist und welches Register einen Wert zurückgibt.
- `#[repr(C)]` zwingt Rust, eine Struktur genau so anzuordnen, wie es der C-Compiler tun würde, wobei die Feldreihenfolge und -auffüllung fixiert werden, sodass das Byte-Layout niemals verändert wird

Warum wird die C-ABI gewählt? Weil sie der kleinste gemeinsame Nenner für alle Sprachen ist, die LLVMs eBPF-Backend unterstützt: Rust, C, Zig oder sogar handgeschriebenes Assembly. Unabhängig davon, welche Toolchain den Bytecode erzeugt, muss die Solana-Laufzeitumgebung die Eintrittsfunktion deines Programms anhand des Rohnamens aufrufen und drei Zeiger in die richtigen Register schieben; die Einhaltung der C-ABI garantiert, dass dies für Code funktioniert, der von jeder LLVM-basierten Sprache erzeugt wird.

#### Entrypoint 

Der `entrypoint!()` ist das einzige Symbol, das jedes Solana-Programm bereitstellen muss. Es ist der Übergabepunkt, an dem die Solana-Laufzeit vom Loader in deinen Code springt.

Vor dem Sprung packt der Loader alles, was eine Anweisung benötigt, in einen flachen, C-ähnlichen Datensatz, der auf der Eingabeseite der BPF-VM gespeichert wird. Das Makro entpackt dann diesen Datensatz und übergibt deinem Rust-Code drei sichere Slices und Referenzen:
- **program_id**: der Public Key des Programms, das gerade ausgeführt wird.
- **accounts**: ein Zeiger auf ein zusammenhängendes Array von AccountInfo-Datensätzen sowie deren Länge.
- **instruction_data**: ein Zeiger-plus-Länge-Slice von Rohbytes, die von der Transaktion bereitgestellt werden.

Das Makro wird:
- Diese Rohzeiger in sichere Rust-Slices umwandeln.
- Panics abfangen, damit sie zu sauberen `ProgramError::Custom`Codes werden, anstatt die VM zum Absturz zu bringen.
- Alles an eine benutzerdefinierte Funktion (oft genannt `process_instruction`) weiterleiten, die ein `ProgramResult` zurückgibt.

Hier ist eine Beschreibung des einzelnen, flachen Datensatzes, den der Solana-Loader auf der Eingabeseite der BPF-VM platziert, bevor er zu deinem Entrypoint springt.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`: Anzahl der gesendeten Konten.
- `account_info`: die Roh-Kontodatensätze in der Anweisung, einer nach dem anderen.
- `instruction_len`: wie viele Bytes an Anweisungsdaten folgen.
- `instruction_data`: die Anweisung selbst
- `program_id`: die 32-Byte `Pubkey` des ausgeführten Programms.

Jedes Element des `account_info`Arrays folgt dann demselben gepackten Layout:

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`: stelle sicher, dass die Daten nicht "neu deserialisiert" werden, wenn dasselbe Konto mehrmals in der Liste erscheint, indem du es überspringst. `0xFF` bedeutet "einzigartig"; jeder andere Wert ist der Index, den es kopiert.
- `is_signer` / `is_writable` / `executable`: Einzelbyte-Flags, die die Laufzeit verwendet, damit dein Programm Logik und CPIs ohne zusätzliche Syscalls steuern kann.
- `alignment`: Ein Platzhalter-Vier-Byte-Slot, der die gesamte Struktur 8-Byte-ausgerichtet hält. Pinocchio verwendet ihn, um die ursprüngliche Datenlänge während Reallocs zu verfolgen.
- `key` / `owner` / `lamports`: Die minimal notwendigen Daten, die jedes Konto haben sollte.
- `data_len` + `data`: Die Daten variabler Länge, die das Konto haben könnte.
- `padding`: Der Loader reserviert vorab 10.240 Bytes, die maximale Größe eines Kontos, damit die Kontodaten sich ändern und wachsen können, ohne den Speicher zu verschieben.
- `align_padding`: Zusätzliche Füllbytes, falls erforderlich, damit der nächste `AccountRaw` immer noch an einer 8-Byte-Grenze beginnt (wichtig für einige eBPF-Hosts).
- `rent_epoch`: Epoche, in der das Konto als nächstes Miete zahlen muss; wird aus Kompatibilitätsgründen beibehalten, obwohl die Mieteinziehung pausiert ist.

#### Syscalls 

Ein **Systemaufruf** oder Syscall ist die Schnittstelle, über die unprivilegierter Code privilegierte Dienste von seinem Host anfordert. Wenn ein Syscall ausgeführt wird, wechselt die CPU vom Benutzermodus in einen vertrauenswürdigen, privilegierten Modus; die Laufzeitumgebung führt dann die angeforderte Aktion aus, und die Kontrolle wird mit einem Statuscode zurückgegeben. Diese Indirektion verhindert, dass Sandbox-Code direkt auf Host-Speicher oder I/O zugreift, wodurch Sicherheit und Determinismus gewahrt bleiben.

Auf Solana kann BPF-Bytecode nicht selbstständig hashen, loggen oder eine programmübergreifende Ausführung (CPI) durchführen. Stattdessen ruft es benannte Syscalls wie `sol_log`, `sol_sha256`, `sol_invoke_signed` auf.

Jede Syscall-Nummer ist einfach ein Index in der Dispatch-Tabelle des Loaders. Der Loader führt die angeforderte Operation aus und gibt ein `u64` Statuswort zurück (null für Erfolg, ungleich null für Fehler).

Zum Beispiel verpackt `sol_invoke_signed` eine Anweisung, ihre Kontoliste und alle PDA-Signer-Seeds, übergibt sie an den Loader, und der Loader führt die CPI unter der richtigen Autorität wie folgt aus:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Der Vault-Code" id="the-vault-code" level="h2" />

Nachdem wir jeden Baustein eines "crate-losen" Solana-Programms entpackt haben, können wir den Vault selbst skizzieren. Denken Sie daran, ein Vault macht genau zwei Dinge:
- **Einzahlen** von Lamports in eine PDA, die vom öffentlichen Schlüssel des Besitzers abgeleitet wird.
- **Abheben** derselben Lamports zu einem späteren Zeitpunkt; nur durch den Besitzer.

Jede Anweisung enthält daher drei Konten:
- **Besitzer** (Unterzeichner, beschreibbar): Der Benutzer, der Gelder einzahlt oder abhebt.
- **Vault** (beschreibbar): Eine PDA, in der alle Lamports enthalten sind.
- **System-Programm**: Konto, das für die Lamport-Übertragung benötigt wird.

Bevor wir beginnen, müssen wir ein neues Projekt erstellen. Führen Sie dazu diesen Befehl in Ihrem Terminal aus:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

In `Cargo.toml` hinzufügen:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Vorlage

Alles wird in `lib.rs` untergebracht. Auf einen Blick wird die Datei Syscall-Shims (kleine, #[repr(C)] Strukturen, die die rohen Syscall-Layouts spiegeln, die wir benötigen) und Datenoffsets als Konstanten enthalten (um die Arbeit mit Rohdaten zu erleichtern).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Konto-Prüfungen

Bevor wir `deposit` oder `withdraw` ausführen können, muss der Einstiegspunkt sicherstellen, dass die Transaktion uns genau die richtigen Konten gegeben hat und dass jedes die erwarteten Flags aufweist.

Da wir auf der Ebene der rohen Zeiger arbeiten, wird jede Prüfung mit einfacher Zeigerarithmetik und direkten Ladevorgängen durchgeführt.

Die ersten acht Bytes des Eingabedatensatzes enthalten account_len. Für diesen Tresor erwarten wir drei Konten: Eigentümer, Tresor-PDA und das System-Programm:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Wir fahren mit der Überprüfung jedes Kontos fort. Die zuvor definierten Layout-Offsets ermöglichen es uns, jedes Flag zu überprüfen, ohne die vollständige Struktur zu deserialisieren.

Für das erste Konto, den Unterzeichner, führen wir folgende Prüfungen durch: 
- Muss eindeutig sein (is_duplicate == 0xff)
- Beschreibbar (wir werden seine Lamports ändern)
- Unterzeichner
- Nicht ausführbar
- Darf keine Daten haben

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Wir speichern auch den öffentlichen Schlüssel des Eigentümers für die spätere PDA-Prüfung:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Für das zweite Konto, den Tresor, führen wir folgende Prüfungen durch:
- Beschreibbar (wir werden seine Lamports ändern)
- Im Besitz des System-Programms
- Datenlänge muss null sein (wir speichern hier keinen Zustand)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Wir erfassen auch den öffentlichen Schlüssel des Tresors für die spätere PDA-Prüfung:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Für das letzte Konto, das System-Programm, führen wir folgende Prüfungen durch: 
- Muss ausführbar sein
- Sein Schlüssel muss SYSTEM_PROGRAM_ID entsprechen

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Überprüfung der Anweisungen

Nach der Kontovalidierung können wir endlich die Anweisungs-Payload parsen. Wir verwenden den gleichen Ansatz wie ein natives Programm, indem wir das erste Byte als Diskriminator nutzen:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

Von hier aus verzweigen wir entweder in den Einzahlungs- oder Auszahlungs-Handler, mit der Gewissheit, dass jedes Konto und jedes Flag genau den Erwartungen des Tresors entspricht.

#### Einzahlungslogik

Wir beginnen mit einer detaillierten Durchsicht der Einzahlungsanweisung. Alle Überprüfungen stehen am Anfang; sobald sie bestanden sind, erstellen wir eine System-Programm-Überweisung und führen sie aus.

Die Anweisungsdaten dieser Instruktion sehen wie folgt aus:
- Byte 0 ist der Diskriminator (`0x00` für Einzahlung).
- Byte 1 ist der Bump, den du für die PDA-Prüfung wiederverwenden wirst.
- Bytes 2-9 enthalten den Lamport-Betrag im Little-Endian-Format, der überprüft und abgelehnt wird, wenn er 0 beträgt.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Danach hashen wir den Owner-Schlüssel mit dem Syscall `sol_sha256`, zusammen mit dem Bump, der Programm-ID und dem eindeutigen String "ProgramDerivedAddress".

Wir vergleichen das Ergebnis mit dem Tresor-Schlüssel, den wir während der Kontoprüfungen gespeichert haben. Wenn sie sich unterscheiden, wird `InvalidSeeds` zurückgegeben.

Wenn sie sich unterscheiden, wird `InvalidSeeds` zurückgegeben.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Schließlich können wir die System-Programm-Überweisung erstellen.

Das System-Programm verwendet einen vier-Byte-Diskriminator (für Überweisungen ist dieser Wert 2) und benötigt zusätzlich 8 Bytes, die den Betrag darstellen, den wir vom `from_account` zum `to_account` überweisen möchten.

Dann müssen wir ein kleines Array von zwei SolAccountMeta-Werten erstellen: from = owner (Unterzeichner, beschreibbar), to = vault (beschreibbar). Wir kombinieren das mit dem `instruction_data`, um eine `SolInstruction`Struktur zu erstellen:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Aber bevor wir den `sol_invoke_signed_c` Syscall aufrufen, müssen wir zwei `SolAccountInfo` Strukturen erstellen, eine für den Besitzer und eine für den
Tresor, die Zeiger auf ihre Lamport-Guthaben und Datensegmente genau dort bereitstellen, wo der Loader sie im Speicher abgelegt hat.

Danach können wir den Syscall aufrufen, indem wir den Instruktionszeiger, den Zeiger auf unser zweielementiges `SolAccountInfo` Array und die Kontoanzahl (2) übergeben. Da die äußere Transaktion bereits vom Besitzer signiert ist, werden hier keine PDA-Seeds benötigt, daher ist das `signers_seeds_addr` Argument NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Abheben-Logik

Die Abheben-Anweisung ähnelt der Einzahlung, weist jedoch einige wichtige Unterschiede auf. Die Anweisungsdaten sind einfacher:
- Byte 0 ist der Diskriminator (`0x01` für Abheben).
- Byte 1 ist der Bump, den du für die PDA-Prüfung wiederverwenden wirst.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Wir führen die gleiche PDA-Prüfung wie bei der Einzahlung durch, unter Verwendung des öffentlichen Schlüssels des Besitzers, des Bumps, der Programm-ID und des eindeutigen Strings "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Der Hauptunterschied beim Abheben besteht darin, dass wir die Transaktion mit dem PDA selbst signieren müssen. Dazu müssen wir die Seeds angeben, die zur Ableitung des PDA verwendet wurden. Wir erstellen ein `SolSignerSeedsC` Array mit zwei Elementen:
- Der öffentliche Schlüssel des Besitzers (32 Bytes)
- Der Bump (1 Byte)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Dann erstellen wir die Überweisungsanweisung des System-Programms, diesmal jedoch vom Tresor zum Besitzer. Die Anweisungsdaten sind die gleichen wie bei der Einzahlung:
- Vier-Byte-Diskriminator (Wert 2 für Überweisung)
- Acht Bytes für den Betrag (den wir aus den Lamports des Tresors erhalten)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Die Account-Metas sind im Vergleich zur Einzahlung umgekehrt:
- Erstes Konto ist der Tresor (beschreibbar, Unterzeichner)
- Zweites Konto ist der Eigentümer (beschreibbar)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Schließlich rufen wir `sol_invoke_signed_c` mit der Anweisung, den Kontoinformationen und den Unterzeichner-Seeds auf, die wir zuvor erstellt haben:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Abschließende Bemerkungen" id="closing-remarks" level="h2" />

Obwohl dieser Low-Level-Ansatz zum Schreiben von Solana-Programmen extrem erscheinen mag, dient er einem wichtigen Bildungszweck. Wir empfehlen nicht, dass du deine Programme auf diese Weise schreibst; tatsächlich raten wir dringend dazu, etablierte Frameworks und Crates zu verwenden, die diese Komplexitäten abstrahieren. Das Verständnis der zugrundeliegenden Mechanik ist jedoch von unschätzbarem Wert.

Jede Abstraktion, die wir in der Solana-Entwicklung verwenden, sei es `solana_program`, `anchor` oder ein anderes Framework, basiert auf diesen grundlegenden Bausteinen. Indem wir die Schichten zurückziehen und die rohe Mechanik untersuchen, gewinnen wir ein tieferes Verständnis für:

1. Wie die Solana-Laufzeitumgebung mit unseren Programmen interagiert
2. Warum bestimmte Designentscheidungen in höheren Frameworks getroffen wurden
3. Wo potenzielle Optimierungen existieren könnten
4. Wie man Probleme besser debuggen kann, wenn sie auftreten

Dieses Wissen ist nicht nur akademisch; es ist praktisch. Wenn du die Grundlagen verstehst, kannst du:
- Effizientere Programme schreiben, indem du informierte Entscheidungen über Datenstrukturen und Speichernutzung triffst
- Probleme besser diagnostizieren und beheben, wenn sie auftreten
- Zum Ökosystem beitragen, indem du die Tools verbesserst, die wir alle nutzen
- Fundierte Entscheidungen darüber treffen, wann bestimmte Abstraktionen verwendet werden sollten und wann näher am Metall gearbeitet werden sollte

Denk daran, das Ziel dieser Übung war nicht, dir beizubringen, wie man Programme ohne Crates schreibt, sondern dir zu helfen zu verstehen, was diese Crates unter der Haube tun. Dieses Verständnis ist der erste Schritt zum Schreiben besserer, effizienterer Solana-Programme, unabhängig davon, welche Tools du verwenden möchtest.
