import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Byte by Byte：無框架程式的剖析

![圖像測試](/graphics/banners/research-crateless-program.png)

如果你曾經編寫過 Solana 程式，你一定使用過像 `solana_program`、`pinocchio` 這樣的 crate，或者使用過某些框架，而這些框架在底層使用了這些 crate，例如 `anchor`、`steel`...

但你是否曾經想過，如果這些 crate 不存在，我們需要做些什麼？歡迎來到低層次 101，我們將會創建一個完全手工編寫、無框架的 Solana 程式。

<ArticleSection name="低層次 Solana 101" id="low-level-solana-101" level="h2" />

在我們捲起袖子手工編寫一個完整的 vault 範例之前，我們需要了解一些關於 Solana 程式的基本知識。

#### `[repr(C)]` 和 `extern C`

當你查看任何低層次的 Solana 範例時，兩種模式會反覆出現：

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

- `extern "C"` 告訴 Rust 編譯器暴露（或期望）一個遵循 C ABI 的符號；這是一種調用約定，定義了哪些 eBPF 寄存器攜帶參數、堆疊如何佈局以及哪個寄存器返回值。
- `#[repr(C)]` 強制 Rust 將 struct 排列得與 C 編譯器完全一致，鎖定字段順序和填充，確保字節佈局永遠不變。

為什麼選擇 C ABI？因為它是 LLVM 的 eBPF 後端支持的每種語言的最低共同標準：Rust、C、Zig，甚至是手工編寫的匯編。不管哪個工具鏈生成了位元碼，Solana 運行時需要通過原始名稱調用你的程式的入口函數，並將三個指針放入正確的寄存器中；遵循 C ABI 保證了任何基於 LLVM 的語言生成的程式碼都能正常運行。

#### 入口點

`entrypoint!()` 是每個 Solana 程式必須公開的唯一符號。這是 Solana 執行環境從載入器跳轉到您的程式碼的交接點。

在跳轉之前，載入器會將指令所需的所有內容打包成一個平坦的 C 樣式記錄，並存儲在 BPF VM 的輸入頁面上。然後，宏會解包該記錄，並將三個安全的切片和引用交給您的 Rust：
- **program_id**：當前執行的程式的公鑰。
- **accounts**：指向 AccountInfo 記錄的連續數組的指針，以及其長度。
- **instruction_data**：由交易提供的原始位元組的指針加長度切片。

該宏將：
- 將這些原始指針轉換為安全的 Rust 切片。
- 捕捉 panic，將其轉換為乾淨的 `ProgramError::Custom` 錯誤碼，而不是使 VM 崩潰。
- 將所有內容轉發到用戶定義的函數（通常稱為 `process_instruction`），該函數返回 `ProgramResult`。

以下是 Solana 載入器在跳轉到您的入口點之前，放置在 BPF VM 的輸入頁面上的單一平坦記錄的描述。

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`：傳入的帳戶數量。
- `account_info`：指令中的原始帳戶記錄，一個接一個。
- `instruction_len`：後續指令數據的位元組數量。
- `instruction_data`：指令本身。
- `program_id`：正在運行的程式的 32 位元 `Pubkey`。

`account_info` 數組的每個元素都遵循相同的打包佈局：

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`：如果同一帳戶在列表中多次出現，請跳過它以確保不會 "重新反序列化" 數據。`0xFF` 表示 "唯一"；任何其他值則是其複製的索引。
- `is_signer` / `is_writable` / `executable`：執行環境使用的單位元標誌，使您的程式能夠在不需要額外系統調用的情況下控制邏輯和 CPI。
- `alignment`：一個佔位的四位元組槽，保持整個結構 8 位元組對齊。Pinocchio 在重新分配期間將其重新用於跟蹤原始數據長度。
- `key` / `owner` / `lamports`：每個帳戶應具有的最低可行數據。
- `data_len` + `data`：帳戶可能具有的可變長度數據。
- `padding`：載入器預先分配 10,240 位元組，這是帳戶的最大大小，因此帳戶數據可以在不移動記憶體的情況下進行更改和增長。
- `align_padding`：如果需要，額外的填充，以便下一個 `AccountRaw` 仍然從 8 位元組邊界開始（對某些 eBPF 主機很重要）。
- `rent_epoch`：帳戶下一次必須支付租金的時期；為了兼容性而保留，即使租金收取已暫停。

#### 系統呼叫 

**系統呼叫**（system call 或 syscall）是未受權限的程式碼向其主機請求受權服務的入口。當進行系統呼叫時，CPU 會從用戶模式切換到受信任的特權模式；運行時環境隨後執行請求的操作，並以狀態碼返回控制權。這種間接方式可防止沙盒程式碼直接接觸主機記憶體或 I/O，從而保證安全性和確定性。

在 Solana 上，BPF 位元碼無法自行進行雜湊、記錄或執行跨程式調用（CPI）。相反，它會調用命名的系統呼叫，例如 `sol_log`、`sol_sha256`、`sol_invoke_signed`。

每個系統呼叫號碼只是加載器調度表中的一個索引。加載器執行請求的操作並返回一個 `u64` 狀態字（成功為零，失敗為非零）。

例如，`sol_invoke_signed` 將指令、其帳戶列表以及任何 PDA 簽名者種子打包，交給加載器，而加載器在適當的授權下執行 CPI，如下所示：

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="The Vault Code" id="the-vault-code" level="h2" />

現在我們已經拆解了「無 crate」Solana 程式的每個構建塊，我們可以概述保險庫本身。請記住，保險庫只執行兩個操作：
- **存入** lamports 到從擁有者公鑰派生的 PDA 中。
- **提取**相同的 lamports；僅限擁有者提取。

因此，每個指令將攜帶三個帳戶：
- **擁有者**（簽名者，可寫入）：存入或提取資金的用戶。
- **保險庫**（可寫入）：包含所有 lamports 的 PDA。
- **系統程式**：執行 lamport 轉移所需的帳戶。

在開始之前，我們需要創建一個新項目，為此請在終端中運行以下命令：

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

在 `Cargo.toml` 中新增：

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### 模板

所有內容將存放於 `lib.rs` 中。簡單來說，該檔案將包含系統調用填充（小型的 #[repr(C)] 結構體，用於鏡像我們需要的原始系統調用佈局）以及作為常數的數據偏移量（以便更輕鬆地處理原始數據）。

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### 帳戶檢查

在我們執行 `deposit` 或 `withdraw` 之前，入口點必須確保交易提供了完全正確的帳戶，並且每個帳戶都具有預期的標誌。

由於我們在處理原始指針層級，每個檢查都通過簡單的指針運算和直接加載完成。

輸入記錄的前八個字節包含 account_len。對於此保險庫，我們預期有三個帳戶：擁有者、保險庫 PDA 和系統程序：

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

我們繼續檢查每個帳戶，之前定義的佈局偏移量讓我們能夠在不反序列化完整結構的情況下檢查每個標誌的合理性。

對於第一個帳戶（簽署者），我們執行以下檢查：
- 必須是唯一的（is_duplicate == 0xff）
- 可寫（我們將更改其 lamports）
- 簽署者
- 不可執行
- 必須沒有數據

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我們還會存儲擁有者的公鑰，以便稍後進行 PDA 檢查：

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

對於第二個帳戶（保險庫），我們執行以下檢查：
- 可寫（我們將更改其 lamports）
- 由系統程序擁有
- 數據長度必須為零（我們不在此存儲狀態）

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

我們還會獲取保險庫的公鑰，以便稍後進行 PDA 檢查：

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

對於最後一個帳戶（系統程序），我們執行以下檢查：
- 必須是可執行的
- 其密鑰必須等於 SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### 指令檢查

在帳戶驗證後，我們終於可以解析指令的有效負載。我們採用與原生程序相同的方法，使用第一個字節作為識別符：

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

從這裡，我們分支到存款或提款處理程序，確保每個帳戶和標誌都完全符合保險庫的預期。

#### 存款邏輯

我們將從更詳細的存款指令流程開始。所有檢查都在前面完成；一旦通過，我們會構建一個系統程序轉賬並調用它。

此指令的數據如下所示：
- 字節 0 是識別符（`0x00` 表示存款）。
- 字節 1 是您將重用於 PDA 檢查的 bump 值。
- 字節 2-9 以小端格式保存 lamport 金額，如果金額為 0，則會被檢查並拒絕。

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

之後，我們使用 `sol_sha256` 系統調用，將擁有者密鑰與 bump、程序 ID 和唯一字符串 "ProgramDerivedAddress" 進行哈希處理。

我們將結果與在帳戶檢查期間存儲的保險庫密鑰進行比較。如果它們不同，則返回 `InvalidSeeds`。

如果它們不同，則返回 `InvalidSeeds`。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

最後，我們終於可以構建系統程序轉賬。

系統程序使用四字節識別符（對於轉賬，該值為 2），並需要額外的 8 個字節來表示我們希望從 `from_account` 轉賬到 `to_account` 的金額。

然後，我們需要構建一個包含兩個 SolAccountMeta 值的小型數組：from = owner（簽名者，可寫），to = vault（可寫）。我們將其與 `instruction_data` 結合，創建一個 `SolInstruction` 結構：

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

但在調用 `sol_invoke_signed_c` 系統調用之前，我們需要構建兩個 `SolAccountInfo` 結構體，一個用於擁有者，一個用於保管庫，這些結構體提供指向其 lamport 餘額和數據切片的指針，正好是加載器在內存中留下的位置。

之後，我們可以通過傳遞指令指針、指向兩個元素的 `SolAccountInfo` 數組的指針以及賬戶數量（2）來調用系統調用。由於外部交易已由擁有者簽署，因此此處不需要 PDA 種子，因此 `signers_seeds_addr` 參數為 NULL。

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### 提取邏輯

提取指令與存款類似，但有幾個關鍵區別。指令數據更簡單：
- 字節 0 是識別符（提取的 `0x01`）。
- 字節 1 是您將重用的 PDA 檢查的 bump。

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

我們執行與存款相同的 PDA 檢查，使用擁有者的公鑰、bump、程序 ID 和唯一字符串 "ProgramDerivedAddress"：

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

提取的關鍵區別在於我們需要使用 PDA 本身簽署交易。為此，我們需要提供用於派生 PDA 的種子。我們創建一個包含兩個元素的 `SolSignerSeedsC` 數組：
- 擁有者的公鑰（32 字節）
- bump（1 字節）

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

然後我們構建系統程序轉賬指令，但這次是從保管庫到擁有者。指令數據與存款相同：
- 四字節識別符（轉賬的值為 2）
- 八字節金額（我們從保管庫的 lamports 獲取）

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

帳戶的元數據與存款相比是相反的：
- 第一個帳戶是保管庫（可寫入，簽署者）
- 第二個帳戶是擁有者（可寫入）

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

最後，我們使用之前創建的指令、帳戶信息和簽署者種子來調用 `sol_invoke_signed_c`：

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="結語" id="closing-remarks" level="h2" />

雖然這種編寫 Solana 程式的低層次方法看起來極端，但它具有重要的教育意義。我們並不是建議你以這種方式編寫程式；事實上，我們強烈建議使用已建立的框架和函式庫來抽象掉這些複雜性。然而，理解底層機制是非常有價值的。

我們在 Solana 開發中使用的每一個抽象層，無論是 `solana_program`、`anchor`，還是其他框架，都是基於這些基本構建塊之上的。通過剝開這些層次並檢視原始機制，我們可以更深入地理解：

1. Solana 運行時如何與我們的程式互動
2. 為什麼高層框架做出了某些設計決策
3. 潛在的優化可能存在於哪裡
4. 當問題發生時如何更好地進行調試

這些知識不僅僅是學術性的；它們是實用的。當你理解了基礎，你可以：
- 通過對數據結構和記憶體使用的知情決策來編寫更高效的程式
- 當問題出現時更好地診斷和修復
- 通過改進我們所有人使用的工具為生態系統做出貢獻
- 在使用某些抽象層和更接近底層工作之間做出明智的決定

請記住，這次練習的目標不是教你如何在沒有函式庫的情況下編寫程式，而是幫助你理解這些函式庫在底層做了什麼。這種理解是編寫更好、更高效的 Solana 程式的第一步，無論你選擇使用哪些工具。
