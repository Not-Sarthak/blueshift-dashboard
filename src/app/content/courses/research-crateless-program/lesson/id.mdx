import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Byte demi Byte: Anatomi Program Tanpa Crate

![Image Test](/graphics/banners/research-crateless-program.png)

Jika Anda pernah menulis program Solana, Anda pasti telah menggunakan crate seperti `solana_program`, `pinocchio` atau framework yang menggunakan salah satu crate tersebut di balik layar seperti `anchor`, `steel`...

Tapi pernahkah Anda bertanya-tanya apa yang perlu kita lakukan jika crate-crate ini tidak ada? Selamat datang di low-level 101 di mana kita akan membuat program Solana yang sepenuhnya dibuat secara manual, tanpa crate.

<ArticleSection name="Solana Low-level 101" id="low-level-solana-101" level="h2" />

Sebelum kita menggulung lengan baju dan membuat contoh vault secara manual, kita perlu memahami beberapa dasar tentang program Solana

#### `[repr(C)]` dan `extern C`

Ketika Anda melihat contoh Solana low-level, dua pola muncul berulang kali:

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

- `extern "C"` memberi tahu kompiler Rust untuk mengekspos (atau mengharapkan) simbol yang mengikuti ABI C; konvensi pemanggilan yang mendefinisikan register eBPF mana yang membawa argumen, bagaimana tata letak stack, dan register mana yang mengembalikan nilai.
- `#[repr(C)]` memaksa Rust untuk mengatur struct persis seperti yang dilakukan kompiler C, mengunci urutan field dan padding sehingga tata letak byte tidak pernah berubah

Mengapa ABI C dipilih? Karena ini adalah common denominator terendah di semua bahasa yang didukung oleh backend eBPF LLVM: Rust, C, Zig, atau bahkan assembly yang ditulis tangan. Tidak peduli toolchain mana yang menghasilkan bytecode, runtime Solana perlu memanggil fungsi entry program Anda dengan nama mentah dan memasukkan tiga pointer ke register yang benar; mematuhi ABI C menjamin bahwa ini akan berfungsi untuk kode yang dihasilkan oleh bahasa berbasis LLVM manapun.

#### Entrypoint 

`entrypoint!()` adalah simbol tunggal yang harus diekspor oleh setiap program Solana. Ini adalah titik serah terima di mana runtime Solana melompat dari loader ke dalam kode Anda.

Sebelum lompatan, loader mengemas semua yang dibutuhkan oleh instruksi ke dalam satu catatan gaya-C yang disimpan pada halaman input BPF VM. Makro kemudian membongkar catatan tersebut dan memberikan Rust Anda tiga slice dan referensi yang aman:
- **program_id**: pubkey dari program yang sedang dieksekusi.
- **accounts**: pointer ke array yang berdekatan dari catatan AccountInfo, plus panjangnya.
- **instruction_data**: slice pointer-plus-length dari byte mentah yang disediakan oleh transaksi.

Makro akan:
- Mengubah pointer mentah tersebut menjadi slice Rust yang aman.
- Menangkap panic sehingga menjadi kode `ProgramError::Custom` yang bersih alih-alih membuat VM crash.
- Meneruskan semuanya ke fungsi yang ditentukan pengguna (sering disebut `process_instruction`) yang mengembalikan `ProgramResult`.

Berikut adalah deskripsi catatan tunggal dan datar yang ditempatkan oleh loader Solana di halaman input BPF VM sebelum melompat ke entrypoint Anda.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len`: jumlah akun yang dikirim.
- `account_info`: catatan akun mentah dalam instruksi, satu setelah yang lain.
- `instruction_len`: berapa banyak byte data instruksi yang mengikuti.
- `instruction_data`: instruksi itu sendiri
- `program_id`: 32-byte `Pubkey` dari program yang sedang dijalankan.

Setiap elemen dari array `account_info` kemudian mengikuti tata letak yang sama:

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate`: pastikan untuk tidak "mendeserialkan ulang" data jika akun yang sama muncul lebih dari sekali dalam daftar dengan melewatkannya. `0xFF` berarti "unik"; nilai lainnya adalah indeks yang disalin.
- `is_signer` / `is_writable` / `executable`: flag satu byte yang digunakan runtime sehingga program Anda dapat mengatur logika dan CPI tanpa syscall tambahan.
- `alignment`: Slot empat byte placeholder yang menjaga seluruh struct tetap selaras 8-byte. Pinocchio menggunakannya kembali untuk melacak panjang data asli selama reallocs.
- `key` / `owner` / `lamports`: Data minimum yang diperlukan yang harus dimiliki setiap akun.
- `data_len` + `data`: Data panjang variabel yang mungkin dimiliki akun.
- `padding`: Loader mengalokasikan 10_240 byte, ukuran maksimum sebuah akun, sehingga data akun dapat berubah dan tumbuh di tempat tanpa memindahkan memori.
- `align_padding`: Pengisi tambahan, jika diperlukan, sehingga `AccountRaw` berikutnya tetap dimulai pada batas 8-byte (penting untuk beberapa host eBPF).
- `rent_epoch`:	Epoch ketika akun harus membayar sewa berikutnya; dipertahankan untuk kompatibilitas meskipun pengumpulan sewa ditangguhkan.

#### Syscalls 

**System call**, atau syscall, adalah pintu masuk yang melaluinya kode tanpa hak istimewa meminta layanan istimewa dari host-nya. Ketika syscall dibuat, CPU beralih dari mode pengguna ke mode tepercaya dan istimewa; runtime kemudian melakukan tindakan yang diminta, dan kontrol kembali dengan kode status. Pengalihan ini mencegah kode yang di-sandbox menyentuh memori host atau I/O secara langsung, menjaga keamanan dan determinisme.

Di Solana, bytecode BPF tidak dapat melakukan hash, log, atau melakukan cross-program invocation (CPI) dengan sendirinya. Sebagai gantinya, ia memanggil syscall bernama seperti `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Setiap nomor syscall hanyalah indeks dalam tabel pengiriman loader. Loader mengeksekusi operasi yang diminta dan mengembalikan kata status `u64` (nol untuk sukses, bukan nol untuk kegagalan).

Misalnya, `sol_invoke_signed` mengemas instruksi, daftar akunnya, dan seed penandatangan PDA, menyerahkannya ke loader, dan loader melakukan CPI di bawah otoritas yang tepat seperti ini:

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Kode Vault" id="the-vault-code" level="h2" />

Sekarang setelah kita membongkar setiap blok pembangun program Solana "tanpa crate", kita dapat menguraikan vault itu sendiri. Ingat, vault melakukan persis dua hal:
- **Deposit** lamport ke dalam PDA yang diturunkan dari kunci publik pemilik.
- **Withdraw** lamport yang sama nanti; hanya oleh pemilik.

Setiap instruksi akan membawa tiga akun:
- **Owner** (penandatangan, dapat ditulis): Pengguna yang menyetor atau menarik dana.
- **Vault** (dapat ditulis): PDA tempat semua lamport disimpan.
- **System Program**: akun yang diperlukan untuk melakukan transfer lamport.

Sebelum memulai, kita perlu membuat proyek baru. Untuk melakukannya, jalankan perintah ini di terminal Anda:

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

Dalam `Cargo.toml` tambahkan:

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Template 

Semuanya akan berada di `lib.rs`. Secara sekilas, file ini akan berisi Syscall Shims (struct kecil, #[repr(C)] yang mencerminkan tata letak syscall mentah yang kita butuhkan), dan offset data sebagai konstanta (untuk memudahkan bekerja dengan data mentah).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Pemeriksaan Akun

Sebelum kita dapat menjalankan `deposit` atau `withdraw`, entrypoint harus memastikan bahwa transaksi memberikan kita akun yang tepat dan masing-masing memiliki flag yang diharapkan.

Karena kita bekerja pada level pointer mentah, setiap pemeriksaan dilakukan dengan matematika pointer sederhana dan pemuatan langsung.

Delapan byte pertama dari catatan input menyimpan account_len. Untuk vault ini kita mengharapkan tiga akun: owner, vault PDA, dan System Program:

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Kita melanjutkan dengan memeriksa setiap akun, offset tata letak yang kita definisikan sebelumnya memungkinkan kita memeriksa setiap flag tanpa melakukan deserialisasi struktur lengkap.

Untuk akun pertama, penandatangan, ini adalah pemeriksaan yang kita lakukan: 
- Harus unik (is_duplicate == 0xff)
- Dapat ditulis (kita akan mengubah lamports-nya)
- Penandatangan
- Tidak dapat dieksekusi
- Tidak boleh memiliki data 

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Kita juga menyimpan kunci publik pemilik untuk pemeriksaan PDA nanti:

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Untuk akun kedua, vault, ini adalah pemeriksaan yang kita lakukan:
- Dapat ditulis (kita akan mengubah lamports-nya)
- Dimiliki oleh System Program
- Panjang data harus nol (kita tidak menyimpan state di sini)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Kita juga mengambil kunci publik vault untuk pemeriksaan PDA nanti:

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Untuk akun terakhir, system program, ini adalah pemeriksaan yang kita lakukan: 
- Harus dapat dieksekusi
- Kuncinya harus sama dengan SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Pemeriksaan instruksi

Setelah validasi akun, akhirnya kita dapat mengurai muatan instruksi. Dan kita mengambil pendekatan yang sama seperti program native dengan menggunakan byte pertama sebagai diskriminator:

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

Dari sini kita bercabang ke handler deposit atau withdraw, dengan keyakinan bahwa setiap akun dan flag adalah tepat seperti yang diharapkan oleh vault.

#### Logika Deposit

Kita akan mulai dengan penjelasan yang lebih rinci tentang instruksi deposit. Semua pemeriksaan berada di bagian depan; setelah lolos, kita membuat transfer System-Program dan menjalankannya.

Data instruksi dari instruksi ini terlihat seperti ini:
- Byte 0 adalah diskriminator (`0x00` untuk deposit).
- Byte 1 adalah bump yang akan digunakan kembali untuk pemeriksaan PDA.
- Byte 2-9 berisi jumlah lamport dalam little-endian yang akan diperiksa dan ditolak jika jumlahnya 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Setelah itu kita melakukan hash pada kunci owner menggunakan syscall `sol_sha256`, dengan bump, ID program, dan string unik "ProgramDerivedAddress".

Kita membandingkan hasilnya dengan kunci vault yang kita simpan selama pemeriksaan akun. Jika berbeda, akan mengembalikan `InvalidSeeds`.

Jika berbeda, akan mengembalikan `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Terakhir, akhirnya kita dapat membuat transfer System-Program.

System Program menggunakan diskriminator empat byte (untuk transfer nilainya adalah 2) dan memerlukan 8 byte tambahan yang mewakili jumlah yang ingin kita transfer dari `from_account` ke `to_account`

Kemudian kita perlu membangun array kecil dari dua nilai SolAccountMeta: from = owner (penandatangan, dapat ditulis), to = vault (dapat ditulis). Kita menggabungkannya dengan `instruction_data` untuk membuat struct `SolInstruction`:

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Tetapi sebelum memanggil syscall `sol_invoke_signed_c` kita perlu membangun dua struct `SolAccountInfo`, satu untuk pemilik dan satu untuk
vault yang menyediakan pointer ke saldo lamport dan irisan data mereka tepat di tempat loader meninggalkannya di memori.

Setelah itu kita dapat memanggil syscall dengan meneruskan pointer instruksi, pointer ke array `SolAccountInfo` dua elemen, dan jumlah akun (2). Karena transaksi luar sudah ditandatangani oleh pemilik, tidak diperlukan seed PDA di sini, jadi argumen `signers_seeds_addr` adalah NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Logika Penarikan

Instruksi penarikan mirip dengan deposit, tetapi dengan beberapa perbedaan kunci. Data instruksinya lebih sederhana:
- Byte 0 adalah diskriminator (`0x01` untuk penarikan).
- Byte 1 adalah bump yang akan Anda gunakan kembali untuk pemeriksaan PDA.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Kita melakukan pemeriksaan PDA yang sama seperti pada deposit, menggunakan kunci publik pemilik, bump, ID program dan string unik "ProgramDerivedAddress":

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Perbedaan utama dalam penarikan adalah kita perlu menandatangani transaksi dengan PDA itu sendiri. Untuk melakukan ini, kita perlu menyediakan seed yang digunakan untuk menurunkan PDA. Kita membuat array `SolSignerSeedsC` dengan dua elemen:
- Kunci publik pemilik (32 byte)
- Bump (1 byte)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Kemudian kita menyusun instruksi transfer Program Sistem, tetapi kali ini dari vault ke pemilik. Data instruksinya sama dengan deposit:
- Diskriminator empat byte (nilai 2 untuk transfer)
- Delapan byte untuk jumlah (yang kita dapatkan dari lamport vault)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Account meta dibalik dibandingkan dengan deposit:
- Akun pertama adalah vault (writable, signer)
- Akun kedua adalah pemilik (writable)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Terakhir, kita memanggil `sol_invoke_signed_c` dengan instruksi, informasi akun, dan signer seeds yang telah kita buat sebelumnya:

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Penutup" id="closing-remarks" level="h2" />

Meskipun pendekatan tingkat rendah untuk menulis program Solana ini mungkin terlihat ekstrem, hal ini memiliki tujuan edukasi yang penting. Kami tidak menyarankan anda menulis program dengan cara ini; sebenarnya, kami sangat merekomendasikan penggunaan framework dan crate yang sudah mapan yang mengabstraksikan kompleksitas ini. Namun, memahami mekanisme yang mendasarinya sangatlah berharga.

Setiap abstraksi yang kita gunakan dalam pengembangan Solana, baik itu `solana_program`, `anchor`, atau framework lainnya, dibangun di atas blok-blok dasar ini. Dengan membuka lapisan dan memeriksa mekanisme dasarnya, kita mendapatkan pemahaman yang lebih dalam tentang:

1. Bagaimana runtime Solana berinteraksi dengan program kita
2. Mengapa keputusan desain tertentu dibuat dalam framework tingkat tinggi
3. Di mana potensi optimasi mungkin ada
4. Bagaimana cara lebih baik dalam men-debug masalah ketika terjadi

Pengetahuan ini tidak hanya akademis; ini praktis. Ketika anda memahami fondasinya, anda dapat:
- Menulis program yang lebih efisien dengan membuat keputusan yang tepat tentang struktur data dan penggunaan memori
- Lebih baik dalam mendiagnosis dan memperbaiki masalah ketika muncul
- Berkontribusi pada ekosistem dengan meningkatkan alat yang kita semua gunakan
- Membuat keputusan yang tepat tentang kapan menggunakan abstraksi tertentu dan kapan bekerja lebih dekat dengan level dasar

Ingat, tujuan dari latihan ini bukanlah untuk mengajarkan anda cara menulis program tanpa crate, tetapi untuk membantu anda memahami apa yang dilakukan crate-crate tersebut di balik layar. Pemahaman ini adalah langkah pertama menuju penulisan program Solana yang lebih baik dan lebih efisien, terlepas dari alat mana yang anda pilih untuk digunakan.
