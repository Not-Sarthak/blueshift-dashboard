import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Octet par octet : l'anatomie d'un programme sans crate

![Test d'image](/graphics/banners/research-crateless-program.png)

Si vous avez écrit un programme Solana, vous avez certainement utilisé un crate comme `solana_program`, `pinocchio` ou un framework qui utilisait l'un de ces crates sous le capot comme `anchor`, `steel`...

Mais vous êtes-vous déjà demandé ce que nous devrions faire si ces crates n'existaient pas ? Bienvenue dans le cours 101 de bas niveau où nous allons créer un programme Solana entièrement fait à la main, sans crate.

<ArticleSection name="Solana bas niveau 101" id="low-level-solana-101" level="h2" />

Avant de retrousser nos manches et de créer manuellement un exemple complet de coffre-fort, nous devons comprendre quelques principes fondamentaux des programmes Solana

#### `[repr(C)]` et `extern C`

Lorsque vous examinez n'importe quel exemple Solana de bas niveau, deux modèles apparaissent encore et encore :

```rust
#[repr(C)]              
pub struct MyState { … }

pub unsafe extern "C" fn entrypoint(ptr: *mut u8) -> u64 { … }
```

- `extern "C"` indique au compilateur Rust d'exposer (ou d'attendre) un symbole qui suit l'ABI C ; la convention d'appel qui définit quels registres eBPF portent les arguments, comment la pile est organisée et quel registre renvoie une valeur.
- `#[repr(C)]` force Rust à organiser une structure exactement comme le ferait le compilateur C, verrouillant l'ordre des champs et le remplissage pour que la disposition des octets ne change jamais

Pourquoi l'ABI C est-elle choisie ? Parce que c'est le plus petit dénominateur commun entre tous les langages que le backend eBPF de LLVM prend en charge : Rust, C, Zig, ou même l'assembleur écrit à la main. Peu importe quel outil produit le bytecode, le runtime Solana doit appeler la fonction d'entrée de votre programme par son nom brut et placer trois pointeurs dans les registres appropriés ; s'en tenir à l'ABI C garantit que cela fonctionnera pour le code produit par n'importe quel langage basé sur LLVM.

#### Point d'entrée 

Le `entrypoint!()` est le symbole unique que chaque programme Solana doit exposer. C'est le point de transfert où le runtime Solana passe du chargeur à votre code.

Avant le saut, le chargeur regroupe tout ce dont une instruction a besoin dans un enregistrement plat de style C stocké sur la page d'entrée de la VM BPF. La macro décompresse ensuite cet enregistrement et transmet à votre Rust trois tranches et références sécurisées :
- **program_id** : la clé publique du programme qui est en cours d'exécution.
- **accounts** : un pointeur vers un tableau contigu d'enregistrements AccountInfo, plus une longueur.
- **instruction_data** : une tranche pointeur-plus-longueur d'octets bruts fournis par la transaction.

La macro va :
- Convertir ces pointeurs bruts en tranches Rust sécurisées.
- Capturer les paniques pour qu'elles deviennent des codes `ProgramError::Custom` propres au lieu de faire planter la VM.
- Transmettre tout à une fonction définie par l'utilisateur (souvent appelée `process_instruction`) qui renvoie un `ProgramResult`.

Voici une description de l'enregistrement unique et plat que le chargeur Solana place dans la page d'entrée de la VM BPF avant de sauter vers votre point d'entrée.

```rust
pub struct Entrypoint {
    account_len: u64,
    account_info: [AccountRaw; account_len]
    instruction_len: u64,
    instruction_data: [u8; instruction_len]
    program_id: [u8; 32],
}
```

- `account_len` : nombre de comptes envoyés.
- `account_info` : les enregistrements de compte bruts dans l'instruction, l'un après l'autre.
- `instruction_len` : combien d'octets de données d'instruction suivent.
- `instruction_data` : l'instruction elle-même
- `program_id` : les 32 octets du `Pubkey` du programme en cours d'exécution.

Chaque élément du tableau `account_info` suit ensuite la même disposition compacte :

```rust
pub struct AccountRaw {
    is_duplicate: u8,
    is_signer: u8,
    is_writable: u8,
    executable: u8,
    alignment: u32,
    key: [u8; 32],
    owner: [u8; 32],
    lamports: u64,
    data_len: usize,
    data: [u8; data_len],
    padding: [u8; 10_240],
    alignment_padding: [u8; ?],
    rent_epoch: i64,
}
```

- `is_duplicate` : assurez-vous de ne pas "redésérialiser" les données si le même compte apparaît plus d'une fois dans la liste en le sautant. `0xFF` signifie "unique" ; toute autre valeur est l'index qu'il copie.
- `is_signer` / `is_writable` / `executable` : drapeaux d'un octet que le runtime utilise pour que votre programme puisse contrôler la logique et les CPI sans appels système supplémentaires.
- `alignment` : un emplacement de quatre octets qui maintient toute la structure alignée sur 8 octets. Pinocchio le réutilise pour suivre la longueur des données d'origine pendant les réallocations.
- `key` / `owner` / `lamports` : les données minimales viables que chaque compte devrait avoir.
- `data_len` + `data` : les données de longueur variable que le compte pourrait avoir.
- `padding` : le chargeur préalloue 10 240 octets, la taille maximale d'un compte, afin que les données du compte puissent changer et croître sur place sans déplacer la mémoire.
- `align_padding` : remplissage supplémentaire, si nécessaire, pour que le prochain `AccountRaw` commence toujours sur une limite de 8 octets (important pour certains hôtes eBPF).
- `rent_epoch` : époque à laquelle le compte doit payer le loyer suivant ; conservé pour la compatibilité même si la collecte des loyers est en pause.

#### Appels système 

Un **appel système**, ou syscall, est la porte par laquelle un code non privilégié demande un service privilégié à son hôte. Lorsqu'un appel système est effectué, le CPU passe du mode utilisateur à un mode privilégié et fiable ; le runtime exécute alors l'action demandée, puis rend le contrôle avec un code d'état. Cette indirection empêche le code en bac à sable de manipuler directement la mémoire ou les E/S de l'hôte, préservant ainsi la sécurité et le déterminisme.

Sur Solana, le bytecode BPF ne peut pas effectuer de hachage, de journalisation ou d'invocation inter-programme (CPI) par lui-même. Au lieu de cela, il invoque des appels système nommés tels que `sol_log`, `sol_sha256`, `sol_invoke_signed`.

Chaque numéro d'appel système est simplement un index dans la table de distribution du chargeur. Le chargeur exécute l'opération demandée et renvoie un mot d'état `u64` (zéro pour succès, non-zéro pour échec).

Par exemple, `sol_invoke_signed` empaquette une instruction, sa liste de comptes et les seeds de signataire PDA, les transmet au chargeur, et le chargeur effectue le CPI sous l'autorité appropriée comme ceci :

```rust
/// Solana BPF syscall for invoking a signed instruction.
fn sol_invoke_signed_c(
    instruction_addr: *const u8,
    account_infos_addr: *const u8,
    account_infos_len: u64,
    signers_seeds_addr: *const u8,
    signers_seeds_len: u64,
) -> u64;
```

<ArticleSection name="Le code du coffre-fort" id="the-vault-code" level="h2" />

Maintenant que nous avons décomposé chaque élément constitutif d'un programme Solana "sans crate", nous pouvons décrire le coffre-fort lui-même. Rappelez-vous, un coffre-fort fait exactement deux choses :
- **Déposer** des lamports dans un PDA dérivé de la clé publique du propriétaire.
- **Retirer** ces mêmes lamports plus tard ; uniquement par le propriétaire.

Chaque instruction comportera donc trois comptes :
- **Propriétaire** (signataire, modifiable) : L'utilisateur qui dépose ou retire des fonds.
- **Coffre-fort** (modifiable) : Un PDA où tous les lamports sont contenus.
- **Programme système** : compte nécessaire pour effectuer le transfert de lamports.

Avant de commencer, nous devons créer un nouveau projet. Pour ce faire, exécutez cette commande dans votre terminal :

```
# create workspace
cargo new blueshift_vault --lib --edition 2021
cd blueshift_vault
```

Dans `Cargo.toml` ajoutez :

```
[lib]
crate-type = ["lib", "cdylib"]
```

#### Modèle

Tout sera dans `lib.rs`. En un coup d'œil, le fichier contiendra des Shims de Syscall (de petites structures #[repr(C)] qui reflètent les dispositions brutes des syscalls dont nous aurons besoin), et des décalages de données comme constantes (pour faciliter le travail avec les données brutes).

```rust
#![no_std]

const ACCOUNT_RAW_LEN: usize = 10_336;
const INSTRUCTION_LEN_LEN: usize = 8;

const ACCOUNT_OFFSET: usize = 8;
const IS_DUPLICATE_OFFSET: usize = 0;
const IS_SIGNER_OFFSET: usize = 1;
const IS_WRITABLE_OFFSET: usize = 2;
const EXECUTABLE_OFFSET: usize = 3;
const ALIGNMENT_OFFSET: usize = 4;
const KEY_OFFSET: usize = 8;
const OWNER_OFFSET: usize = 40;
const LAMPORTS_OFFSET: usize = 72;
const DATA_LEN_OFFSET: usize = 80;
const DATA_OFFSET: usize = 88;
const PADDING_OFFSET: usize = 10_248;
const RENT_EPOCH_OFFSET: usize = 10_248;

// Base58 encoded to 11111111111111111111111111111111
const SYSTEM_PROGRAM_ID: [u8; 32] = [0u8; 32];

#[allow(unused)]
extern "C" { 
    fn sol_sha256(
        vals: *const u8, 
        val_len: u64, 
        hash_result: *mut [u8;32]
    ) -> u64;

    fn sol_log_(
        input: *const u8, 
        len: u64
    ) -> u64;

    fn sol_log_64_(
        arg1: u64, 
        arg2: u64, 
        arg3: u64, 
        arg4: u64, 
        arg5: u64
    ) -> u64;

    fn sol_invoke_signed_c(
        instruction_addr: *const u8,
        account_infos_addr: *const u8,
        account_infos_len: u64,
        signers_seeds_addr: *const u8,
        signers_seeds_len: u64,
    ) -> u64;
}

#[repr(C)]
struct SolInstruction {
    program_id_addr: u64,
    accounts_addr: u64,
    accounts_len: usize,
    data_addr: u64,
    data_len: usize,
}

#[repr(C)]
struct SolAccountMeta {
    pubkey_addr: u64,
    is_writable: bool,
    is_signer: bool,
}

#[repr(C)]
struct SolAccountInfo {
    key_addr: u64,
    lamports_addr: u64,
    data_len: u64,
    data_addr: u64,
    owner_addr: u64,
    rent_epoch: u64,
    is_signer: bool,
    is_writable: bool,
    executable: bool,
}

#[repr(C)]
struct SolSignerSeed {
    seed: *const u8,
    seed_len: u64,
}

#[repr(C)]
struct SolSignerSeedC {
    addr: u64,
    len: u64,
}

#[repr(C)]
struct SolSignerSeedsC {
    addr: u64,
    len: u64,
}

// 22222222222222222222222222222222222222222222
pub const ID: [u8; 32] = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {

}
```

#### Vérifications des comptes

Avant de pouvoir exécuter `deposit` ou `withdraw`, le point d'entrée doit s'assurer que la transaction nous a fourni exactement les bons comptes et que chacun possède les indicateurs attendus.

Comme nous travaillons au niveau des pointeurs bruts, chaque vérification est effectuée avec de simples calculs de pointeurs et des chargements directs.

Les huit premiers octets de l'enregistrement d'entrée contiennent account_len. Pour ce coffre-fort, nous attendons trois comptes : le propriétaire, le PDA du coffre-fort et le Programme Système :

```rust
// Check that we have 3 accounts: Signer, Vault, Program
if *(input as *const u64) != 3 {
    sol_log_("Invalid number of accounts".as_ptr(), 26);
    return 1010; // NotEnoughAccountKeys Error
}
```

Nous continuons en vérifiant chaque compte, les décalages de disposition que nous avons définis précédemment nous permettent de vérifier chaque indicateur sans désérialiser la structure complète.

Pour le premier compte, le signataire, voici les vérifications que nous effectuons : 
- Doit être unique (is_duplicate == 0xff)
- Modifiable (nous changerons ses lamports)
- Signataire
- Non exécutable
- Ne doit pas avoir de données

```rust
if *(input.add(ACCOUNT_OFFSET) as *const u32) != 0x0101ff {
    sol_log_("Invalid Account 1 Data: Non-Duplicate, Writable, Signer, Non-Executable Check Failed".as_ptr(), 58);
    return 1003; // InvalidAccountData Error
}
if *(input.add(ACCOUNT_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 1 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Nous conservons également la clé publique du propriétaire pour la vérification PDA ultérieure :

```rust
let signer_key = *(input.add(ACCOUNT_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Pour le deuxième compte, le coffre-fort, voici les vérifications que nous effectuons :
- Modifiable (nous changerons ses lamports)
- Détenu par le Programme Système
- La longueur des données doit être zéro (nous ne stockons pas d'état ici)

```rust
const ACCOUNT_2_OFFSET: usize = ACCOUNT_OFFSET + ACCOUNT_RAW_LEN;

if *(input.add(ACCOUNT_2_OFFSET + IS_WRITABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 2 Data: Writable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != pinocchio_system::ID {
    sol_log_("Invalid Account 2 Data: Owner is not the System Program".as_ptr(), 48);
    return 1022; // InvalidAccountOwner Error
}

if *(input.add(ACCOUNT_2_OFFSET + DATA_LEN_OFFSET) as *const usize) != 0 {
    sol_log_("Invalid Account 2 Data: Data Length is not 0".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}
```

Nous récupérons également la clé publique du coffre-fort pour la vérification PDA ultérieure :

```rust
let vault_key = *(input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as *const [u8; 32]);
```

Pour le dernier compte, le programme système, voici les vérifications que nous effectuons : 
- Doit être exécutable
- Sa clé doit être égale à SYSTEM_PROGRAM_ID

```rust
const ACCOUNT_3_OFFSET: usize = ACCOUNT_2_OFFSET + ACCOUNT_RAW_LEN;
const SYSTEM_PROGRAM_DATA_LENGTH: usize = 14 + 2;

if *(input.add(ACCOUNT_3_OFFSET + EXECUTABLE_OFFSET) as *const u8) != 1 {
    sol_log_("Invalid Account 3 Data: Executable Check Failed".as_ptr(), 38);
    return 1003; // InvalidAccountData Error
}

if *(input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as *const [u8; 32]) != SYSTEM_PROGRAM_ID {
    sol_log_("Invalid Account 3 Data: Owner is not the System Program".as_ptr(), 48);
    return 1003; // InvalidAccountData Error
}
```

#### Vérifications d'instruction

Après la validation du compte, nous pouvons enfin analyser la charge utile de l'instruction. Et nous adoptons la même approche qu'un programme natif en utilisant le premier octet comme discriminateur :

```rust
const INSTRUCTION_OFFSET: usize = ACCOUNT_3_OFFSET + ACCOUNT_RAW_LEN + SYSTEM_PROGRAM_DATA_LENGTH + INSTRUCTION_LEN_LEN;

let discriminator = *(input.add(INSTRUCTION_OFFSET) as *const u8);
match discriminator {
    0 => {
        sol_log_("Deposit".as_ptr(), 7);

        // deposit logic …

        return 0; // Success
    }
    1 => {
        sol_log_("Withdraw".as_ptr(), 8);

        // withdraw logic …

        return 0; // Success
    }
    _ => {
        sol_log_("Invalid Instruction".as_ptr(), 20);
        return 1002; // InvalidInstructionData Error
    }
}
```

À partir de là, nous nous dirigeons soit vers le gestionnaire de dépôt, soit vers celui de retrait, avec la certitude que chaque compte et indicateur correspond exactement à ce que le coffre-fort attend.

#### Logique de dépôt

Nous allons commencer par une analyse plus détaillée de l'instruction de dépôt. Toutes les vérifications sont placées en amont ; une fois qu'elles sont validées, nous créons un transfert System-Program et l'invoquons.

Les données d'instruction de cette instruction se présentent comme suit :
- L'octet 0 est le discriminateur (`0x00` pour le dépôt).
- L'octet 1 est le bump que vous réutiliserez pour la vérification PDA.
- Les octets 2-9 contiennent le montant en lamports en little-endian qui sera vérifié et rejeté s'il équivaut à 0.

```rust
let amount = *(input.add(INSTRUCTION_OFFSET + 2) as *const u64);
if amount == 0 {
    return 1002; // InvalidInstructionData Error
}
```

Ensuite, nous hachons la clé du propriétaire en utilisant l'appel système `sol_sha256`, avec le bump, l'ID du programme et la chaîne unique "ProgramDerivedAddress".

Nous comparons le résultat avec la clé du coffre-fort que nous avons mise de côté lors des vérifications de compte. S'ils diffèrent, cela renvoie `InvalidSeeds`.

S'ils diffèrent, cela renvoie `InvalidSeeds`.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

Enfin, nous pouvons créer le transfert System-Program.

Le System Program utilise un discriminateur de quatre octets (pour le transfert, cette valeur est 2) et nécessite 8 octets supplémentaires qui représentent le montant que nous voulons transférer du `from_account` au `to_account`

Nous devons ensuite construire un petit tableau de deux valeurs SolAccountMeta : from = owner (signataire, modifiable), to = vault (modifiable). Nous combinons cela avec le `instruction_data` pour créer une structure `SolInstruction` :

```rust
let mut instruction_data = [0; 12];
instruction_data[0] = 2; // discriminator
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes()); // amount

let accounts_addr: [SolAccountMeta; 2] = [
    // from_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    // to_account
    SolAccountMeta { 
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];

// Create the instruction
let instruction = SolInstruction {
    program_id_addr: input.add(ACCOUNT_3_OFFSET + KEY_OFFSET) as u64,
    accounts_addr: accounts_addr.as_ptr() as u64,
    accounts_len: 2,
    data_addr: instruction_data.as_ptr() as u64,
    data_len: 12,
};
```

Mais avant d'appeler le syscall `sol_invoke_signed_c`, nous devons construire deux structures `SolAccountInfo`, une pour le propriétaire et une pour le
coffre qui fournissent des pointeurs vers leurs soldes de lamports et leurs tranches de données exactement là où le chargeur les a laissés en mémoire.

Après cela, nous pouvons appeler le syscall en passant le pointeur d'instruction, le pointeur vers votre tableau `SolAccountInfo` à deux éléments, et le nombre de comptes (2). Comme la transaction externe est déjà signée par le propriétaire, aucune graine PDA n'est nécessaire ici, donc l'argument `signers_seeds_addr` est NULL.

```rust
let account_infos_addr: [SolAccountInfo; 2] = [
    SolAccountInfo {
        is_signer: true,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
    SolAccountInfo {
        is_signer: false,
        is_writable: true,
        executable: false,
        key_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        lamports_addr: input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as u64,
        data_len: 0,
        data_addr: input.add(ACCOUNT_2_OFFSET + DATA_OFFSET) as u64,
        owner_addr: input.add(ACCOUNT_2_OFFSET + OWNER_OFFSET) as u64,
        rent_epoch: 0,
    },
];

// Invoke the instruction with the signer seeds
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    core::ptr::null(),
    0,
);
```

#### Logique de retrait

L'instruction de retrait est similaire au dépôt, mais avec quelques différences clés. Les données d'instruction sont plus simples :
- L'octet 0 est le discriminateur (`0x01` pour le retrait).
- L'octet 1 est le bump que vous réutiliserez pour la vérification PDA.

```rust
let bump: u8 = *(input.add(INSTRUCTION_OFFSET + 1) as *const u8);
```

Nous effectuons la même vérification PDA que lors du dépôt, en utilisant la clé publique du propriétaire, le bump, l'ID du programme et la chaîne unique "ProgramDerivedAddress" :

```rust
let data = [
    signer_key.as_ref(),
    &[bump],
    ID.as_ref(),
    b"ProgramDerivedAddress",
];

let mut pda = core::mem::MaybeUninit::<[u8; 32]>::uninit();
sol_sha256(
    &data as *const _ as *const u8,
    4,
    pda.as_mut_ptr(),
);

if vault_key != *pda.as_ptr() {
    sol_log_("Invalid PDA address".as_ptr(), 19);
    return 1013; // InvalidSeeds Error
};
```

La différence clé dans le retrait est que nous devons signer la transaction avec le PDA lui-même. Pour ce faire, nous devons fournir les graines qui ont été utilisées pour dériver le PDA. Nous créons un tableau `SolSignerSeedsC` avec deux éléments :
- La clé publique du propriétaire (32 octets)
- Le bump (1 octet)

```rust
let seeds: [SolSignerSeedsC; 2] = [
    SolSignerSeedsC {
        addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        len: 32,
    },
    SolSignerSeedsC {
        addr: input.add(INSTRUCTION_OFFSET + 1) as u64,
        len: 1,
    },
];

let signer_seeds_addr: [SolSignerSeedsC; 1] = [
    SolSignerSeedsC {
        addr: seeds.as_ptr() as u64,
        len: 2,
    },
];
```

Nous élaborons ensuite l'instruction de transfert du Programme Système, mais cette fois du coffre vers le propriétaire. Les données d'instruction sont les mêmes que pour le dépôt :
- Discriminateur de quatre octets (valeur 2 pour le transfert)
- Huit octets pour le montant (que nous obtenons à partir des lamports du coffre)

```rust
let amount = *(input.add(ACCOUNT_2_OFFSET + LAMPORTS_OFFSET) as *const u64);

let mut instruction_data = [0; 12];
instruction_data[0] = 2;
instruction_data[4..12].copy_from_slice(&amount.to_le_bytes());
```

Les méta-comptes sont inversés par rapport au dépôt :
- Le premier compte est le coffre (modifiable, signataire)
- Le deuxième compte est le propriétaire (modifiable)

```rust
let account_addr: [SolAccountMeta; 2] = [
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_2_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: true,
    },
    SolAccountMeta {
        pubkey_addr: input.add(ACCOUNT_OFFSET + KEY_OFFSET) as u64,
        is_writable: true,
        is_signer: false,
    },
];
```

Enfin, nous appelons `sol_invoke_signed_c` avec l'instruction, les informations de compte et les graines de signature que nous avons créées précédemment :

```rust
sol_invoke_signed_c(
    &instruction as *const SolInstruction as *const u8,
    account_infos_addr.as_ptr() as *const u8,
    2, // Number of accounts
    signer_seeds_addr.as_ptr() as *const u8,
    1,
);
```

<ArticleSection name="Remarques finales" id="closing-remarks" level="h2" />

Bien que cette approche de bas niveau pour écrire des programmes Solana puisse sembler extrême, elle sert un objectif éducatif crucial. Nous ne suggérons pas d'écrire vos programmes de cette façon ; en fait, nous recommandons vivement d'utiliser des frameworks et des crates établis qui abstraient ces complexités. Cependant, comprendre les mécanismes sous-jacents est inestimable.

Chaque abstraction que nous utilisons dans le développement Solana, qu'il s'agisse de `solana_program`, `anchor`, ou tout autre framework, est construite sur ces éléments fondamentaux. En décortiquant les couches et en examinant les mécanismes bruts, nous acquérons une appréciation plus profonde pour :

1. Comment le runtime Solana interagit avec nos programmes
2. Pourquoi certaines décisions de conception ont été prises dans les frameworks de plus haut niveau
3. Où des optimisations potentielles pourraient exister
4. Comment mieux déboguer les problèmes lorsqu'ils surviennent

Cette connaissance n'est pas seulement académique ; elle est pratique. Lorsque vous comprenez les fondements, vous pouvez :
- Écrire des programmes plus efficaces en prenant des décisions éclairées sur les structures de données et l'utilisation de la mémoire
- Mieux diagnostiquer et résoudre les problèmes lorsqu'ils surviennent
- Contribuer à l'écosystème en améliorant les outils que nous utilisons tous
- Prendre des décisions éclairées sur quand utiliser certaines abstractions et quand travailler plus près du métal

Rappelez-vous, l'objectif de cet exercice n'était pas de vous apprendre à écrire des programmes sans crates, mais plutôt de vous aider à comprendre ce que ces crates font sous le capot. Cette compréhension est la première étape vers l'écriture de programmes Solana meilleurs et plus efficaces, quel que soit les outils que vous choisissez d'utiliser.
