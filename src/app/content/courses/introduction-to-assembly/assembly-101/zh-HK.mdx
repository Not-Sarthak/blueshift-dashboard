import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# sBPF Assembly 101

![Introduction to Assembly](/graphics/course-banners/introduction-to-assembly.png)

要了解 sBPF Assembly 及其在 Solana 程式中的角色，我們首先需要了解組合語言，以及它如何將高階程式碼與機器執行連接起來。

<ArticleSection name="The Assembly Language" id="the-assembly-language" level="h2" />

組合語言是機器碼的人類可讀形式：即處理器執行的實際指令。它作為高階程式語言與電腦理解的二進制碼之間的橋樑。

當你編寫像這樣的 Rust 程式碼時：

```rust
let result = a + b;
```

編譯器會通過幾個階段進行翻譯：
1. Rust 原始碼 → 解析和分析
2. 中間表示 → 優化
3. 組合語言 → 人類可讀的指令
4. 機器碼 → 處理器執行的二進制碼

組合語言處於第 3 階段：轉換為二進制之前的最終人類可讀形式。每條組合指令對應於一個處理器操作：例如加法、載入記憶體或跳轉到不同的程式碼段。

<ArticleSection name="The sBPF Virtual Machine" id="the-sbpf-virtual-machine" level="h2" />

Solana sBPF 是 Solana 的自定義版本，基於擴展的 Berkeley Packet Filter (eBPF) 指令集和虛擬機器，執行每個鏈上程式。它創建了一個專門的執行環境：一個 64 位元的暫存器機器，位於你的程式和驗證者的原生 CPU 之間。

可以將 sBPF 想像成一台專為區塊鏈執行設計的電腦：既能快速處理高吞吐量交易，又能在數千個驗證者之間保證安全性和確定性。

與直接在 CPU 上運行的原生組合語言不同，sBPF 程式碼在受控的虛擬機器環境中執行。這個虛擬機器通過在執行前驗證每條指令來保證安全性，防止崩潰、無限迴圈和未授權的記憶體訪問。

儘管有這些安全限制，sBPF 仍然通過`just-in-time`編譯保持高效能，實現接近原生執行速度。

虛擬機還確保了執行的確定性：相同的程式和相同的輸入在全球所有驗證者中都會產生相同的結果。這種一致性對區塊鏈共識至關重要。

此外，sBPF 包括用於帳戶訪問、跨程式調用和運行時互動的系統調用（syscalls）。

### 為什麼理解 sBPF 彙編很重要

雖然 Rust 編譯器能高效地將高階代碼轉換為 sBPF 指令，但理解彙編語言有以下幾個優勢：
- **理解計算成本**：每條 sBPF 指令都會消耗計算單元（CUs）。一行 Rust 代碼可能會編譯成數百條指令——彙編語言可以揭示為什麼某些操作成本高昂。
- **更小的程式大小**：直接用 sBPF 彙編語言編寫的程式比編譯的 Rust 等效程式小得多，從而降低部署成本並改善加載時間。
- **優化機會**：Rust 編譯器生成安全且正確的代碼，但並不總是最有效率的。彙編語言可以揭示冗餘的安全檢查和次優的指令序列。
- **調試和分析**：當程式行為異常時，彙編語言提供了最基礎的真相。您可以精確追踪執行了哪些指令並識別故障點。

### 架構

sBPF 採用一種載入-存儲架構，具有 10 個通用寄存器、一個只讀的堆疊指針，並且沒有複雜的尋址模式。

這種簡單性是有意為之：更少的指令變體能夠加快驗證速度、加快 JIT 編譯速度並提供更可預測的效能。

每次將 eBPF 程式載入內核時，其位元組碼會由 JIT 編譯器轉換為特定於主機 CPU 架構的原生機器指令，然後由虛擬機執行。

### 執行

sBPF 程式通過一個簡單的過程執行。程式計數器（`PC`）跟踪下一步要執行的指令，就像指令列表中的書籤一樣。

執行週期遵循以下步驟：
1. **提取**：讀取程式計數器上的指令
2. **解碼**：解釋指令格式和操作數
3. **執行**：執行操作（修改暫存器、訪問記憶體或更改控制流程）
4. **前進**：將程式計數器移至下一條指令（或在分支時跳轉）
5. **重複**：持續執行直到程式結束

每條指令僅執行一個操作：算術運算、記憶體訪問、比較或函數調用。這種每指令一操作的設計使 sBPF 程式具有可預測性和可分析性。

<ArticleSection name="JIT 編譯器管道" id="the-jit-compiler-pipeline" level="h2" />

sBPF 程式透過即時編譯（JIT）實現高效能。

當你將程式部署到 Solana 時，運行時會執行兩個操作：
- **驗證**：通過檢查無限迴圈、無效記憶體訪問和潛在崩潰來確保程式安全。驗證器分析每條可能的執行路徑以保證安全運行。
- **編譯**：將 sBPF 指令轉換為可直接在驗證器 CPU 上運行的原生機器碼。簡單操作如 `add64 r1, r2` 會轉換為單一的原生加法指令，而複雜操作則會增加額外的安全檢查，但仍然編譯為高效的原生碼。

這種方法以部署時間換取執行速度。程式在部署期間僅需驗證和編譯一次，但會執行數千次，這對區塊鏈效能來說是一個極佳的權衡。

JIT 驗證過程會檢查每條可能的程式路徑，確保記憶體訪問在範圍內、跳轉目標為有效地址，並且執行在計算限制內終止。

JIT 編譯過程將每條 sBPF 指令轉換為等效的原生 CPU 指令。由於大部分執行都在原生碼中進行，虛擬機的開銷極小。

> 理解 sBPF 編譯為原生代碼的原理，可以解釋為什麼算術運算速度快，而進入運行時的系統調用會有額外開銷。這些知識有助於指導優化決策。