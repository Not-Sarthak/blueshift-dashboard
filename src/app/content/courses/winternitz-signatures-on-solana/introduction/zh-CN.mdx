import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Solana上的Winternitz签名

![Solana上的Winternitz签名](/graphics/course-banners/winternitz-signatures-on-solana.png)

与依赖于整数分解或离散对数等数学问题的RSA或ECDSA签名不同，这些签名容易受到量子攻击的威胁，Winternitz签名的安全性完全依赖于加密哈希函数的单向性。

这一根本性的区别使其成为后量子密码学的基石。

<ArticleSection name="什么是Winternitz签名" id="what-is-a-winternitz-signature" level="h2" />

Winternitz一次性签名（WOTS）源自Leslie Lamport在20世纪70年代的开创性工作。Lamport证明了仅使用加密哈希函数而无需复杂的数学假设也可以创建数字签名。

Lamport的原始方案使用两个秘密值对单个位进行签名。要签名位`b`，需要揭示哈希值`H₀`的前像（如果b=0）或`H₁`的前像（如果b=1）。其安全性完全依赖于找到哈希前像的计算不可行性：本质上是从哈希输出反推其输入。

然而，Lamport签名效率极低。签名一个`n-bit`消息需要`2n`个秘密值，并生成`2n`值的签名。对于256位消息，这意味着需要管理512个秘密值并生成512值的签名。

Robert Winternitz在20世纪90年代意识到，与其在基数2中对单个位进行签名，不如在更高的基数（如基数16或基数256）中对更大的“数字”进行签名。这一创新大大减少了密钥和签名的大小，同时保持了相同的安全保证。

<ArticleSection name="数学基础" id="mathematical-foundations" level="h2" />

### Winternitz参数与基数表示

Winternitz签名中的关键参数是`w`，它决定了如何对消息位进行分组：
- 基数：`b = 2^w`
- 数字范围：每个数字表示`w`位，其值范围从`0`到`2^w - 1`

常见的参数选择：
- `w = 1`：每个位置代表1位（值为0或1），相当于二进制的Lamport签名
- `w = 4`：每个位置代表4位（值为0-15），即十六进制表示
- `w = 8`：每个位置代表8位（值为0-255），即二百五十六进制表示

> 较大的`w`值会生成更小的签名，但需要更多的计算以确保安全性。这种权衡是理解WOTS性能特性的基础。

### 哈希链

Winternitz签名使用哈希链——从一个秘密值开始，通过重复应用哈希函数生成的序列：`H⁰(s) = s`，`H¹(s) = H(s)`，`H²(s) = H(H(s))`，...，`Hⁱ(s) = H(H^(i-1)(s))`

其安全性具有不对称性：给定`Hⁱ(s)`，计算任何`Hʲ(s)`，其中`j > i`是简单的（只需对`j-i`进行更多次哈希），但计算任何`Hʲ(s)`，其中`j < i`在计算上是不可行的，因为这需要逆转哈希函数。

### 校验和机制

校验和机制可以防止一种特定类型的伪造攻击。如果没有校验和，攻击者在看到签名后，可能会修改消息，使其需要在某些链上进行更多的哈希操作，然后伪造这些部分。

校验和确保了所有链的总“哈希预算”保持不变：如果攻击者将消息数字修改为更大的值（需要更多的哈希操作），校验和数字会自动变小（需要在其他值中减少哈希操作，这是没有私钥的情况下无法伪造的）。

### 密钥生成过程

对于消息长度为`n`位，Winternitz参数为`w`的情况：

1. 计算签名长度：首先，确定表示任何消息所需的“块”数量。如果消息长度为256位，选择Winternitz参数为`w = 4`，则总共需要64个块：`l₁ = ⌈n/w⌉`。使用公式`l₂ = ⌊log₂(l₁ × (2^w - 1))/w⌋ + 1`，我们可以得出，对于`w = 4`，最大校验和为960，`l₂ = 3`，签名的大小将是`l = l₁ + l₂`

> 在密钥生成过程中，由于尚未选择要签名的消息，因此您无法知道校验和的值，但您仍然需要保留`l₂`的私钥组件用于校验和。

2. 创建随机起点：为每个需要的哈希链生成一个随机的秘密值。这些随机值成为您的私钥组件。可以将每个值视为单独哈希链的“起点”：`sk = (sk₁, sk₂, ..., skₗ)`

3. 对于每个私钥组件，重复应用哈希函数，直到达到最大可能的哈希次数（`2^w - 1`）：`pk = (H^(2^w-1)(sk₁), H^(2^w-1)(sk₂), ..., H^(2^w-1)(skₗ))`

### 签名过程

对消息`M`进行签名：

1. 将消息转换为基数表示形式：`M → (m₁, m₂, ..., m_l₁)`，其中每个`mᵢ ∈ [0, 2^w - 1]`

2. 计算校验和：`c = Σ((2^w - 1) - mᵢ) for i = 1 to l₁`并将c转换为基数表示形式：`c → (c₁, c₂, ..., c_l₂)`

> 为了计算该消息的实际校验和值，我们可以使用适当的校验和私钥组件，并根据校验和数字对其进行正确次数的哈希。

3. 生成签名：基数表示形式指示私钥需要被哈希的次数。

### 验证过程

验证消息`M`的签名σ与公钥`pk`：

1. 重新计算消息表示形式：`M → (m₁, m₂, ..., m_l₁)`

2. 重新计算校验和：`c = Σ((2^w - 1) - mᵢ) → (c₁, c₂, ..., c_l₂)`

3. 对每个签名组件，哈希剩余次数：
   - 对于消息部分：验证`H^((2^w-1)-mᵢ)(σᵢ) = pkᵢ`
   - 对于校验和部分：验证`H^((2^w-1)-cⱼ)(σ_(l₁+j)) = pk_(l₁+j)`

> 验证者从签名者停止的地方“继续”每个哈希链，如果签名有效，将到达已知的公钥终点。

<ArticleSection name="安全性" id="security" level="h2" />

### 一次性使用限制

Winternitz签名是一次性签名（OTS）：每个密钥对只能安全使用一次。

攻击的原理如下：当您使用相同的私钥签署多个消息时，会暴露哈希链中的中间值。

校验和机制要求增加某些消息数字（更多哈希）必须通过减少校验和数字（更少哈希）来平衡。通过多个签名在不同位置暴露中间值，攻击者可以构造伪造签名，利用更高的中间位置进一步提升消息组件，同时利用较低的中间位置平衡校验和，从而遵守总哈希预算的限制。

### 后量子安全性

Winternitz 签名的安全性完全依赖于哈希函数的原像抗性。量子计算机无法高效地反转像 SHA-256 或 SHA-3 这样的加密哈希函数——这与能够在多项式时间内破解 RSA 和 ECDSA 的量子算法（如 Shor 算法）不同。

使用适当参数的 SHA-256 提供了 128 位的后量子安全性，使这些签名即使在后量子时代也适用于长期加密应用。

<ArticleSection name="Winternitz Signatures on Solana" id="winternitz-on-solana" level="h2" />

Solana 当前的加密基础完全依赖于 Ed25519 签名，这种签名通过 Shor 算法容易受到量子攻击。

当量子计算机变得实用时，Solana 上的每个钱包、程序权限和交易都可能被伪造。

后量子迁移不是一夜之间可以完成的事情。系统需要从今天开始设计量子抗性，创建在前量子和后量子世界中都能运行的混合方法。

虽然 Solana 的基础层仍然容易受到量子攻击，但开发者可以使用 Winternitz 签名在其之上构建量子抗性应用程序。
