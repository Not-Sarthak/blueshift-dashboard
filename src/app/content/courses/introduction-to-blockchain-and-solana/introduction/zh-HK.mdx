import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 區塊鏈簡介

![區塊鏈簡介](/graphics/course-banners/introduction-to-blockchain-and-solana.png)

你可能聽過區塊鏈被描述為「數字貨幣」或「互聯網的未來」。這些解釋完全忽略了重點。

區塊鏈是分佈式系統：一個由多台電腦組成的網絡，這些電腦必須在不互相信任的情況下就共享數據達成一致。本課程從基本原理教你了解區塊鏈：它解決的分佈式系統問題、解決方法以及為什麼權衡取捨很重要。

讓我們先了解為什麼構建分佈式系統是計算機科學中最困難的問題之一。

<ArticleSection name="分佈式系統" id="distributed-systems" level="h2" />

大多數人認為從一台電腦擴展到多台電腦只是「更多相同的東西」。這就像認為協調一個人與協調一千個分佈在不同時區且可能無法隨時聯繫到的人是一樣的。

當你在單台電腦上編寫代碼時，你生活在一個可預測的世界中：
- 操作要麼立即成功，要麼立即失敗
- 數據在讀取之間不會神秘地改變
- 時間一致地向前推進
- 當你保存某些東西時，它確實被保存了

讓我們以一個簡單的銀行系統為例。在這種情況下，將 100 美元從 Alice 轉移到 Bob 是非常容易的：

```python
def transfer(from_account, to_account, amount):
    if from_account.balance >= amount:
        from_account.balance -= amount
        to_account.balance += amount
        return "Transfer successful"
    return "Insufficient funds"
```

這一切運行得非常順利……直到你需要擴展。

你的銀行業務增長超過了一台電腦的處理能力，因此你現在將賬戶平均分配到不同的數據庫：
- 伺服器 A：賬戶 1 到 1,000,000
- 伺服器 B：賬戶 1,000,001 到 2,000,000
- 伺服器 C：賬戶 2,000,001 到 3,000,000

現在，Alice（在伺服器 A 上）想要向 Bob（在伺服器 B 上）轉賬 100 美元。這個簡單的轉賬變成了：

```python
def distributed_transfer(alice_server, bob_server, amount):
    # Check Alice's balance on Server A
    if alice_server.get_balance("alice") >= amount:
        alice_server.deduct("alice", amount)    # Step 1
        bob_server.add("bob", amount)           # Step 2
        return "Transfer successful"
    return "Insufficient funds"
```

看起來仍然很簡單？以下是可能出現的問題：
- 網絡分區：伺服器之間的連接在步驟1之後但步驟2之前失敗。Alice的$100消失在數字虛空中。
- 伺服器崩潰：伺服器B在接收到“添加金額”指令後崩潰，但在確認處理之前崩潰。Bob是否收到金額？無人知曉。
- 競爭條件：Alice的兩筆轉賬同時進行。兩者都檢查她的$100餘額，看到她有足夠的資金，然後都繼續進行。Alice現在花費了她並沒有的$100。

### CAP定理

1999年，計算機科學家Eric Brewer提出了CAP定理，該定理指出任何分佈式系統最多只能保證以下三個屬性中的兩個：
- 一致性（C）：所有伺服器始終顯示相同的數據。當Alice的餘額在伺服器A上更改時，其他所有伺服器立即反映這一變化。
- 可用性（A）：即使伺服器崩潰，系統仍然可以運行。如果伺服器A宕機，用戶仍然可以通過伺服器B和C訪問賬戶。
- 分區容錯性（P）：系統能夠在網絡故障將伺服器分隔成孤立組時繼續運行。

我們必須保證分區容錯性，因為網絡分區是不可避免的：電纜會被切斷，路由器會失效，數據中心會斷電。這使我們需要在一致性或可用性之間進行選擇。

傳統銀行系統通常選擇一致性+分區容錯性（CP系統）。它們寧願關閉系統，也不願顯示不正確的賬戶餘額。

社交媒體平台通常選擇可用性+分區容錯性（AP系統）。它們寧願讓你發佈（即使朋友無法立即看到），也不願阻止你發佈內容。

### 拜占庭將軍問題

除了CAP定理，大多數分佈式系統假設參與者是誠實的：他們可能會失敗或斷線，但不會故意欺騙彼此。當參與者可能是惡意的時，這一假設就不成立了。

拜占庭將軍問題由計算機科學家於1982年提出，說明了這一挑戰：

你是一名拜占庭將軍，計劃攻擊一座設防的城市。你有幾位盟軍將軍分佈在城市周圍，每位將軍指揮自己的軍隊。要成功，你必須協調同時進攻。如果有些人進攻而其他人撤退，進攻的部隊將被屠殺。

你只能通過信使進行通信，而某些將軍可能是叛徒，他們希望進攻失敗。叛徒可能會：
- 向一些將軍發送「進攻」信息，向其他人發送「撤退」信息
- 修改忠誠將軍的消息內容
- 與其他叛徒協調以最大化混亂

當你無法區分忠誠將軍和叛徒，且無法信任通信渠道時，如何就「進攻」或「撤退」達成共識？

這似乎是不可能的。幾十年來，計算機科學家認為不可能構建一個同時具備以下特性的系統：
- 拜占庭容錯（即使有惡意參與者也能運行）
- 無需許可（任何人都可以無需批准加入）
- 去中心化（無中央權威）

直到2008年，一位自稱中本聰的人證明了他們是錯的。

### 比特幣：第一個區塊鏈

比特幣是區塊鏈技術的第一個實際應用。雖然加密哈希、數字簽名、點對點網絡等組件早已存在，但中本聰是第一個將它們結合起來，解決數字貨幣雙重支付問題的人。

區塊鏈（Blockchain），或稱為「區塊鏈條」，這個名稱最早出現在原始的比特幣[白皮書](https://bitcoin.org/bitcoin.pdf)中，最終創造了一個同時具備分佈式、拜占庭容錯性和無需許可的系統。

這項突破並非試圖辨別誰值得信任，而是讓撒謊在經濟上比說真話更昂貴。工作量證明（Proof of Work）通過要求參與者消耗真實的計算能量來提出更改來實現這一點。攻擊者需要花費的電力成本將超過他們從攻擊中獲得的收益。