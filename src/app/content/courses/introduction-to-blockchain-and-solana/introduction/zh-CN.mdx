import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 区块链简介

![区块链简介](/graphics/course-banners/introduction-to-blockchain-and-solana.png)

你可能听说过区块链被描述为“数字货币”或“互联网的未来”。这些解释完全没有抓住重点。

区块链是分布式系统：一组计算机网络，它们必须在不互相信任的情况下就共享数据达成一致。本课程从基本原理讲解区块链：它解决的分布式系统问题、解决方法以及权衡的重要性。

让我们先了解为什么构建分布式系统是计算机科学中最难的问题之一。

<ArticleSection name="分布式系统" id="distributed-systems" level="h2" />

大多数人认为，从一台计算机扩展到多台计算机只是“更多相同的事情”。这就像认为协调一个人和协调分布在不同时区、可能并不总是能联系上的一千人是一样的。

当你在单台计算机上编写代码时，你生活在一个可预测的世界中：
- 操作要么立即成功，要么立即失败
- 数据在读取之间不会神秘地改变
- 时间始终向前推进
- 当你保存某些内容时，它确实被保存了

让我们以一个简单的银行系统为例。在这种情况下，将 100 美元从 Alice 转给 Bob 是非常容易的：

```python
def transfer(from_account, to_account, amount):
    if from_account.balance >= amount:
        from_account.balance -= amount
        to_account.balance += amount
        return "Transfer successful"
    return "Insufficient funds"
```

这在单机环境下运行得非常完美……直到你需要扩展。

你的银行业务增长到单台计算机无法处理的程度，因此你现在将账户均匀分布到不同的数据库中：
- 服务器 A：账户 1 到 1,000,000
- 服务器 B：账户 1,000,001 到 2,000,000
- 服务器 C：账户 2,000,001 到 3,000,000

现在，Alice（在服务器 A 上）想要向 Bob（在服务器 B 上）转账 100 美元。这个简单的转账变成了：

```python
def distributed_transfer(alice_server, bob_server, amount):
    # Check Alice's balance on Server A
    if alice_server.get_balance("alice") >= amount:
        alice_server.deduct("alice", amount)    # Step 1
        bob_server.add("bob", amount)           # Step 2
        return "Transfer successful"
    return "Insufficient funds"
```
看起来仍然很简单吗？以下是可能出错的地方：
- 网络分区：服务器之间的连接在步骤 1 之后但在步骤 2 之前失败。Alice 的 100 美元消失在数字虚空中。
- 服务器崩溃：服务器 B 在接收到“添加资金”命令后崩溃，但在确认处理之前崩溃。Bob 收到钱了吗？没人知道。
- 竞争条件：Alice 的两笔转账同时发生。两者都检查了她的 100 美元余额，发现她有足够的资金，并都继续进行。Alice 现在花费了她并没有的 100 美元。

### CAP 定理

1999 年，计算机科学家 Eric Brewer 提出了 CAP 定理，该定理指出任何分布式系统最多只能保证以下三个属性中的两个：
- 一致性 (C)：所有服务器始终显示相同的数据。当 Alice 的余额在服务器 A 上发生变化时，其他所有服务器会立即反映这一变化。
- 可用性 (A)：即使服务器崩溃，系统也能继续工作。如果服务器 A 宕机，用户仍然可以通过服务器 B 和 C 访问账户。
- 分区容错性 (P)：系统能够在网络故障将服务器分隔成孤立组时继续运行。

我们必须保证分区容错性，因为网络分区是不可避免的：电缆会被切断，路由器会失效，数据中心会断电。这使我们需要在一致性和可用性之间做出选择。

传统银行系统通常选择一致性 + 分区容错性（CP 系统）。它们宁愿关闭系统也不愿显示错误的账户余额。

社交媒体平台通常选择可用性 + 分区容错性（AP 系统）。它们宁愿让你发布内容（即使朋友无法立即看到）也不愿完全阻止你发布。

### 拜占庭将军问题

除了 CAP 定理，大多数分布式系统假设参与者是诚实的：他们可能会失败或断开连接，但不会主动欺骗彼此。当参与者可能是恶意的时，这一假设就不成立了。

计算机科学家在 1982 年提出的拜占庭将军问题，说明了这一挑战：

你是一名拜占庭将军，计划攻打一座设防的城市。你有几位盟军将军分布在城市周围，每位将军指挥着自己的军队。为了成功，你必须协调同时发起攻击。如果有些人进攻而另一些人撤退，进攻的部队将被全歼。

你只能通过信使进行通信，而一些将军可能是叛徒，他们希望攻击失败。叛徒可能会：
- 向一些将军发送“进攻”消息，而向另一些将军发送“撤退”消息
- 修改忠诚将军传递的消息
- 与其他叛徒协调以最大化混乱

当你无法区分忠诚的将军和叛徒，也无法信任通信渠道时，如何就“进攻”或“撤退”达成共识？

这似乎是不可能的。几十年来，计算机科学家认为无法构建一个同时具备以下特性的系统：
- 拜占庭容错（即使有恶意参与者也能正常工作）
- 无许可（任何人都可以无需批准加入）
- 去中心化（没有中央权威）

然而在 2008 年，一个自称中本聪的人证明了他们是错的。

### 比特币：第一个区块链

比特币是区块链技术的第一个实际应用。虽然其各个组成部分（如加密哈希、数字签名、点对点网络）在此之前已经存在，但中本聪是第一个将它们结合起来，解决数字货币双重支付问题的人。

区块链，或称为“区块链条”，正如其在最初的比特币[白皮书](https://bitcoin.org/bitcoin.pdf)中所描述的那样，最终创建了一个同时具备分布式、拜占庭容错和无许可特性的系统。

这一突破并不是试图确定谁值得信任，而是让撒谎在经济上比说真话更昂贵。工作量证明通过要求参与者消耗真实的计算能量来提出更改实现了这一点。攻击者需要在电力上花费的成本超过他们通过攻击所能获得的收益。