import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Pengenalan Blockchain

![Pengenalan Blockchain](/graphics/course-banners/introduction-to-blockchain-and-solana.png)

Anda mungkin pernah mendengar blockchain dijelaskan sebagai "uang digital" atau "masa depan internet." Penjelasan-penjelasan ini sama sekali tidak menangkap intinya.

Blockchain adalah sistem terdistribusi: jaringan komputer yang harus menyepakati data bersama tanpa saling mempercayai. Kursus ini mengajarkan blockchain dari prinsip-prinsip dasar: masalah sistem terdistribusi yang dipecahkannya, bagaimana cara memecahkannya, dan mengapa pertukaran nilai (trade-off) itu penting.

Mari kita mulai dengan memahami mengapa membangun sistem terdistribusi adalah salah satu masalah tersulit dalam ilmu komputer.

<ArticleSection name="Sistem Terdistribusi" id="distributed-systems" level="h2" />

Kebanyakan orang berpikir bahwa penskalaan dari satu komputer ke banyak komputer hanyalah "lebih banyak dari hal yang sama." Itu seperti berpikir bahwa mengkoordinasikan satu orang sama dengan mengkoordinasikan seribu orang di zona waktu berbeda yang mungkin tidak selalu dapat dihubungi.

Ketika Anda menulis kode di satu komputer, Anda hidup di dunia yang dapat diprediksi:
- Operasi berhasil atau gagal dengan segera
- Data tidak secara misterius berubah di antara pembacaan
- Waktu bergerak maju secara konsisten
- Ketika Anda menyimpan sesuatu, itu benar-benar tersimpan

Mari kita ambil sistem perbankan sederhana. Mentransfer $100 dari Alice ke Bob dalam kasus itu sangat mudah:

```python
def transfer(from_account, to_account, amount):
    if from_account.balance >= amount:
        from_account.balance -= amount
        to_account.balance += amount
        return "Transfer successful"
    return "Insufficient funds"
```

Ini bekerja dengan sempurna... sampai Anda perlu melakukan penskalaan.

Bank Anda tumbuh melampaui apa yang dapat ditangani oleh satu komputer, jadi sekarang Anda membagi akun secara merata di berbagai database:
- Server A: Akun 1 hingga 1.000.000
- Server B: Akun 1.000.001 hingga 2.000.000
- Server C: Akun 2.000.001 hingga 3.000.000

Sekarang Alice (di Server A) ingin mengirim $100 ke Bob (di Server B). Transfer sederhana itu menjadi:

```python
def distributed_transfer(alice_server, bob_server, amount):
    # Check Alice's balance on Server A
    if alice_server.get_balance("alice") >= amount:
        alice_server.deduct("alice", amount)    # Step 1
        bob_server.add("bob", amount)           # Step 2
        return "Transfer successful"
    return "Insufficient funds"
```

Masih terlihat sederhana? Inilah yang bisa salah:
- Partisi Jaringan: Koneksi antar server gagal tepat setelah Langkah 1 tetapi sebelum Langkah 2. Uang $100 milik Alice menghilang ke dalam kekosongan digital.
- Server Crash: Server B crash setelah menerima perintah "tambah uang" tetapi sebelum mengonfirmasi bahwa perintah telah diproses. Apakah Bob mendapatkan uangnya? Tidak ada yang tahu.
- Kondisi Balapan (Race Conditions): Dua transfer dari Alice terjadi secara bersamaan. Keduanya memeriksa saldo $100 miliknya, melihat bahwa dia memiliki dana yang cukup, dan keduanya dilanjutkan. Alice sekarang telah menghabiskan $100 yang tidak dia miliki.

### Teorema CAP

Pada tahun 1999, ilmuwan komputer Eric Brewer merumuskan Teorema CAP, yang menyatakan bahwa sistem terdistribusi hanya dapat menjamin maksimal dua dari tiga properti berikut:
- Konsistensi (C): Semua server selalu menampilkan data yang sama. Ketika saldo Alice berubah di Server A, setiap server lain segera mencerminkan perubahan ini.
- Ketersediaan (A): Sistem tetap berfungsi meskipun server mengalami crash. Jika Server A mati, pengguna masih dapat mengakses akun melalui Server B dan C.
- Toleransi Partisi (P): Sistem bertahan dari kegagalan jaringan yang memisahkan server menjadi kelompok-kelompok terisolasi.

Kita harus menjamin toleransi partisi karena partisi jaringan tidak dapat dihindari: kabel bisa terpotong, router gagal, pusat data kehilangan daya. Ini membuat kita harus memilih antara Konsistensi ATAU Ketersediaan.

Sistem perbankan tradisional biasanya memilih Konsistensi + Toleransi Partisi (Sistem CP). Mereka lebih memilih untuk menutup sistem daripada menampilkan saldo akun yang tidak benar.

Platform media sosial sering memilih Ketersediaan + Toleransi Partisi (Sistem AP). Mereka lebih memilih membiarkan Anda memposting (meskipun teman-teman tidak dapat melihatnya segera) daripada mencegah Anda memposting sama sekali.

### Masalah Jenderal Bizantium

Selain Teorema CAP, kebanyakan sistem terdistribusi mengasumsikan bahwa para pesertanya jujur: mereka mungkin gagal atau terputus, tetapi tidak akan secara aktif menipu satu sama lain. Asumsi ini tidak berlaku ketika peserta bisa bersifat jahat.

Masalah Jenderal Bizantium, yang dirumuskan oleh ilmuwan komputer pada tahun 1982, menggambarkan tantangan ini:

Anda adalah seorang jenderal Bizantium yang merencanakan serangan ke kota yang dibentengi. Anda memiliki beberapa jenderal sekutu yang ditempatkan di sekitar kota, masing-masing memimpin pasukan mereka sendiri. Untuk berhasil, Anda harus mengkoordinasikan serangan serentak. Jika beberapa menyerang sementara yang lain mundur, pasukan yang menyerang akan dibantai.

Anda berkomunikasi hanya melalui kurir, dan beberapa jenderal mungkin pengkhianat yang ingin serangan gagal. Pengkhianat dapat:
- Mengirim pesan "serang" ke beberapa jenderal dan "mundur" ke yang lain
- Memodifikasi pesan dari jenderal yang setia saat pesan tersebut disampaikan
- Berkoordinasi dengan pengkhianat lain untuk memaksimalkan kebingungan

Bagaimana Anda mencapai konsensus tentang "serang" atau "mundur" ketika Anda tidak dapat membedakan jenderal yang setia dari pengkhianat, dan Anda tidak dapat mempercayai saluran komunikasi?

Ini tampaknya mustahil. Selama beberapa dekade, ilmuwan komputer percaya bahwa Anda tidak bisa membangun sistem yang secara bersamaan:
- Toleran terhadap kesalahan Bizantium (tetap berfungsi meskipun ada peserta yang jahat)
- Tanpa izin (siapa pun dapat bergabung tanpa persetujuan)
- Terdesentralisasi (tidak ada otoritas pusat)

Kemudian pada tahun 2008, seseorang yang menyebut dirinya Satoshi Nakamoto membuktikan bahwa mereka salah.

### Bitcoin: blockchain pertama

Bitcoin adalah implementasi praktis pertama dari teknologi blockchain. Meskipun komponen individualnya sudah ada sebelumnya (hashing kriptografi, tanda tangan digital, jaringan peer-to-peer), Satoshi adalah yang pertama menggabungkannya untuk menyelesaikan masalah pengeluaran ganda untuk mata uang digital.

Blockchain, atau "rantai blok" seperti yang disebut dalam [whitepaper](https://bitcoin.org/bitcoin.pdf) Bitcoin asli, akhirnya menciptakan sistem yang terdistribusi, tahan terhadap kesalahan Byzantine, dan tanpa izin secara bersamaan.

Terobosannya bukan mencoba mengidentifikasi siapa yang harus dipercaya; melainkan membuat kebohongan lebih mahal secara ekonomi daripada mengatakan kebenaran. Proof of Work mencapai ini dengan mengharuskan peserta untuk menggunakan energi komputasi nyata untuk mengusulkan perubahan. Penyerang harus mengeluarkan biaya listrik lebih banyak daripada yang bisa mereka dapatkan dari serangan.