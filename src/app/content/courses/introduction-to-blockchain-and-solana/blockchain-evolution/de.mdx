import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Blockchain-Evolution

Nachdem du nun verstehst, wie Konsensmechanismen und kryptografische Primitive funktionieren, lass uns erkunden, wie sich diese Konzepte von Bitcoins einfachem Werttransfer zu den heutigen programmierbaren Blockchain-Plattformen entwickelt haben.

Jede wichtige Blockchain repräsentiert unterschiedliche technische Entscheidungen und Kompromisse, die durch die grundlegenden Einschränkungen geprägt sind, die wir kennengelernt haben.

<ArticleSection name="Bitcoin" id="bitcoin" level="h2" />

Bitcoin wurde nicht als universeller Computer konzipiert; es wurde entwickelt, um ein spezifisches Problem zu lösen: digitales Geld zu schaffen, das ohne Banken oder Regierungen funktioniert. Jede Designentscheidung bei Bitcoin spiegelt diesen einzigartigen Fokus wider.

### Konsens

Bitcoin verwendet die ursprüngliche Proof-of-Work-Implementierung, die Satoshi entwickelt hat. Miner konkurrieren darum, eine Nonce (Zufallszahl) zu finden, die bei der Hashbildung mit den Blockdaten einen Hash erzeugt, der mit einer bestimmten Anzahl von Nullen beginnt.

Das Netzwerk passt die Schwierigkeit automatisch alle 2.016 Blöcke (ungefähr zwei Wochen) an, um eine durchschnittliche Blockzeit von 10 Minuten beizubehalten.

Dieses Timing ist nicht willkürlich. Schnellere Blöcke würden zu Netzwerkspaltungen führen, bei denen Miner an verschiedenen Blockchain-Versionen arbeiten. Langsamere Blöcke würden Transaktionen schmerzlich langsam machen.

### Das UTXO-Modell

Bitcoin verfolgt keine Kontostände wie Banken. Stattdessen werden einzelne "Münzen" mithilfe von UTXOs (Unspent Transaction Outputs) verfolgt, die ähnlich wie physisches Bargeld funktionieren.

Stell dir vor, du hast drei 20-Euro-Scheine in deiner Brieftasche und möchtest etwas kaufen, das 35 Euro kostet. Du kannst einen 20-Euro-Schein nicht teilen, also gibst du dem Kassierer zwei Scheine (40 Euro) und erhältst 5 Euro zurück. Bitcoin funktioniert genauso:

Nehmen wir an, Alice hat Bitcoin in drei separaten Transaktionen erhalten:
- UTXO #1: 0,5 BTC (von Bob)
- UTXO #2: 0,3 BTC (von Carol)
- UTXO #3: 0,8 BTC (von Dave)

Alices "Guthaben" beträgt 1,6 BTC, aber es gibt kein einzelnes Konto, das diese Zahl speichert. Stattdessen verzeichnet die Blockchain drei separate UTXOs, die Alice ausgeben kann.

Wenn Alice 1,0 BTC an Eve senden möchte, muss sie:
- UTXOs auswählen, die insgesamt mindestens 1,0 BTC ergeben (sie wählt UTXO #1 und #3, insgesamt 1,3 BTC)
- Eine Transaktion erstellen, bei der sie 1,0 BTC an Eve und 0,3 BTC als Wechselgeld an sich selbst zurücksendet
- Die Transaktion mit ihrem privaten Schlüssel signieren, um zu beweisen, dass sie die Eingabe-UTXOs besitzt

Die Transaktion verbraucht UTXOs #1 und #3 (sie sind jetzt "ausgegeben") und erzeugt zwei neue UTXOs: einen für Eve und einen Wechselgeld-UTXO für Alice.

Dieses Modell ermöglicht leistungsstarke Funktionen:
- Parallelisierbare Verarbeitung: Da jeder UTXO nur einmal ausgegeben werden kann, stehen Transaktionen mit verschiedenen UTXOs nicht in Konflikt. Miner können Tausende von Transaktionen gleichzeitig validieren, ohne sich über Doppelausgaben Sorgen zu machen, solange jede Transaktion auf unterschiedliche UTXOs verweist.
- Privatsphäre: Es gibt kein globales Konto, das dein Gesamtguthaben offenlegt. Deine Bitcoins sind auf mehrere UTXOs verteilt, was es Beobachtern erschwert, dein Gesamtvermögen zu ermitteln. Jeder UTXO kann mit einer anderen Adresse verknüpft sein, was die Eigentumsmuster weiter verschleiert.
- Einfache Verifizierung: Jede Transaktion kann unabhängig überprüft werden, indem kontrolliert wird, ob die Eingabe-UTXOs existieren und nicht ausgegeben wurden und ob die digitalen Signaturen gültig sind. Du musst keinen komplexen Kontostatus verwalten oder dir Sorgen machen, dass die Reihenfolge der Transaktionen die Guthaben beeinflusst.
- Atomare Operationen: Entweder eine Transaktion gelingt vollständig (verbraucht alle Eingaben und erzeugt alle Ausgaben) oder sie schlägt vollständig fehl. Es besteht kein Risiko eines Teilzustands, bei dem Geld abgezogen, aber nicht überwiesen wird.

<ArticleSection name="Ethereum" id="ethereum" level="h2" />

Während Bitcoin digitale Zahlungen löste, erkannte Vitalik Buterin eine größere Chance: Was wäre, wenn die Blockchain nicht nur Geld transferieren, sondern jedes Programm ausführen könnte? Diese Vision führte zu Ethereum: dem ersten Allzweck-Blockchain-Computer.

Bitcoins UTXO-Modell funktioniert perfekt für Zahlungen, wird aber umständlich für komplexe Anwendungen, die persistenten Zustand, komplexe Logik und Komponierbarkeit zwischen verschiedenen Programmen benötigen.

### Konsens

Ethereum verwendete ursprünglich Proof of Work, wechselte aber 2022 während "The Merge" zu Proof of Stake. Dieser Übergang erhielt die Sicherheit und brachte entscheidende Vorteile:
- Mathematische Finalität: Nach etwa 13 Minuten werden Transaktionen mathematisch unumkehrbar
- Energieeffizienz: Kein massiver Stromverbrauch mehr
- Zukünftige Upgrades: Proof of Stake ermöglicht Sharding: Die Aufteilung des Netzwerks in parallele Chains für höheren Durchsatz

### Das Kontomodell

Ethereum ersetzte Bitcoins UTXO-System durch vertraute kontobasierte Guthaben und ermöglichte:
- Smart Contracts: Programme, die auf der Blockchain leben und ihren eigenen Zustand verwalten
- Externe Konten: Benutzergesteuerte Konten ähnlich wie Bitcoin-Adressen
- Inter-Contract-Aufrufe: Smart Contracts können nahtlos miteinander interagieren

In Ethereum gibt es zwei Arten von Konten:
- Extern verwaltete Konten (EOAs): Werden von Benutzern mit privaten Schlüsseln kontrolliert, ähnlich wie Bitcoin-Adressen. Sie haben ein Guthaben und können Transaktionen senden.
- Vertragskonten: Werden durch Code gesteuert, nicht durch private Schlüssel. Sie haben ein Guthaben UND speichern ausführbaren Code sowie persistente Daten.

Aus diesem Grund sind Smart Contracts auf Ethereum autonome Programme, die auf der Blockchain leben, ihren eigenen Zustand verwalten und von anderen Konten aufgerufen werden können.

Dieses Kontomodell ermöglicht persistenten Zustand – Daten, die über Transaktionen hinweg bestehen bleiben. Ein Smart Contract kann Informationen aus früheren Interaktionen speichern, komplexe Datenstrukturen verwalten und sich im Laufe der Zeit weiterentwickeln.

Dies ermöglicht Anwendungen wie Kreditprotokolle, Governance-Systeme und komplexe Finanzinstrumente.

All dies ist dank der Ethereum Virtual Machine (EVM) möglich, die auf jedem Knoten läuft und die Blockchain programmierbar macht. Sie definiert, welche Programme ausgeführt werden können, wie sie ausgeführt werden und welche Ressourcen sie verbrauchen.

<ArticleSection name="Solana" id="solana" level="h2" />

Ethereum hat gezeigt, dass Blockchains allgemeine Berechnungen unterstützen können, aber dieser Erfolg offenbarte Skalierbarkeitsprobleme. Mit zunehmender Verbreitung dezentraler Anwendungen führte die Netzwerküberlastung zu hohen Transaktionsgebühren und längeren Bestätigungszeiten.

Diese Einschränkungen stammten aus grundlegenden architektonischen Entscheidungen im Design von Ethereum, die Solana durch architektonische Innovationen zu beheben versucht, indem es Kernkomponenten der Blockchain von Grund auf neu gestaltet.

### Konsens

Solana verwendet Proof of Stake, fügt aber eine entscheidende Innovation hinzu: Proof of History. Anstatt auf einen Konsens darüber zu warten, wann Ereignisse stattgefunden haben, erstellt Solana eine kryptografische Uhr, die alle Transaktionen vor dem Konsens mit einem Zeitstempel versieht. Dies ermöglicht Validatoren, Transaktionen parallel zu verarbeiten, da sie bereits die richtige Reihenfolge kennen.

Diese zeitliche Anordnung ermöglicht einen viel schnelleren Konsens: Solana erzeugt alle 400 Millisekunden Blöcke, verglichen mit Ethereums 12 Sekunden.

### Solana Virtual Machine

Die EVM verarbeitet Transaktionen sequentiell, da Smart Contracts einen globalen Zustand teilen: Wenn ein Vertrag gemeinsam genutzte Daten ändert, müssen alle anderen Transaktionen warten. Dies schafft Engpässe bei wachsender Netzwerknutzung.

Solana überdenkt diese Architektur grundlegend:
- Zustandslose Programme: Im Gegensatz zu Ethereum, wo Smart Contracts Daten intern speichern, sind Solana-Programme zustandslos. Alle Daten befinden sich in separaten Konten, aus denen Programme lesen und in die sie schreiben. Diese Trennung ermöglicht parallele Verarbeitung, da Programme nicht um gemeinsamen Zustand konkurrieren.
- Transaktionsparallelisierung: Solana-Transaktionen müssen im Voraus deklarieren, welche Konten sie lesen und ändern werden. Die Laufzeitumgebung kann dann nicht-konfligierende Transaktionen gleichzeitig auf mehreren CPU-Kernen ausführen. Wenn Transaktion A Konto X und Transaktion B Konto Y modifiziert, können sie parallel ausgeführt werden.
- Optimierte Ausführung: Die SVM verwendet eine registerbasierte Architektur anstelle des stackbasierten Ansatzes der EVM, was den Overhead beim Verschieben von Daten während der Berechnung reduziert. Programme werden zu nativem Maschinencode kompiliert anstatt zu Bytecode, was den Interpretationsoverhead eliminiert.
- Vorhersehbare Kosten: Anstelle von Ethereums festen Gaspreisen, die vor Jahren festgelegt wurden, verwendet Solana dynamische Gebührenmärkte, bei denen die Transaktionskosten die tatsächliche Netzwerknachfrage und die verbrauchten Rechenressourcen widerspiegeln.

Das Ergebnis ist, dass Solana über 5.000 Transaktionen pro Sekunde (TPS) verarbeiten kann, verglichen mit Ethereums 15 TPS, während gleichzeitig eine Finalität unter einer Sekunde und Dezentralisierung gewährleistet werden. Diese Leistung resultiert aus architektonischen Entscheidungen, die parallele Ausführung gegenüber dem sequentiellen Verarbeitungsmodell priorisieren, das vom Single-Thread-Computing übernommen wurde.