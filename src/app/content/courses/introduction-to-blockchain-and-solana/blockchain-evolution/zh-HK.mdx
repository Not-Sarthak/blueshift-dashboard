import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 區塊鏈的演進

現在你已經了解了共識機制和加密基元的運作方式，讓我們來探討這些概念如何從比特幣的簡單價值轉移演變到今天的可編程區塊鏈平台。

每個主要的區塊鏈都代表了不同的工程決策和取捨，這些決策受到我們所學的基本限制的影響。

<ArticleSection name="Bitcoin" id="bitcoin" level="h2" />

比特幣並不是為了成為通用計算機而設計的；它的目的是解決一個特定的問題：創建一種不依賴銀行或政府的數字貨幣。比特幣的每一個設計決策都反映了這一單一目標。

### 共識機制

比特幣使用了中本聰設計的原始工作量證明（Proof of Work）實現。礦工競爭尋找一個隨機數（nonce），當這個數與區塊數據一起進行哈希運算時，會生成一個以特定數量的零開頭的哈希值。

網絡每隔2,016個區塊（大約兩週）會自動調整難度，以保持平均區塊時間為10分鐘。

這個時間設置並非隨意。更快的區塊時間會導致網絡分裂，礦工在不同的區塊鏈版本上工作。而更慢的區塊時間會使交易變得非常緩慢。

### UTXO 模型

比特幣不像銀行那樣追蹤賬戶餘額。相反，它使用未花費交易輸出（UTXO）來追蹤單個「硬幣」，其功能類似於實體現金。

想像一下，你的錢包裡有三張20美元的鈔票，想買一件價值35美元的商品。你不能拆分一張20美元的鈔票，所以你給收銀員兩張鈔票（40美元），並收到5美元的找零。比特幣的運作方式完全相同：

假設 Alice 通過三筆交易收到了比特幣：
- UTXO #1: 0.5 BTC（來自 Bob）
- UTXO #2: 0.3 BTC（來自 Carol）
- UTXO #3: 0.8 BTC（來自 Dave）

Alice 的「餘額」是 1.6 BTC，但並沒有單一帳戶儲存這個數字。相反，區塊鏈記錄了三個分別的 UTXO，這些 UTXO 是 Alice 可以使用的。

當 Alice 想要發送 1.0 BTC 給 Eve 時，她需要：
- 選擇總額至少為 1.0 BTC 的 UTXO（她選擇了 UTXO #1 和 #3，總額為 1.3 BTC）
- 建立一筆交易，將 1.0 BTC 發送給 Eve，並將 0.3 BTC 作為找零發送回自己
- 使用她的私鑰簽署交易，以證明她擁有這些輸入的 UTXO

這筆交易消耗了 UTXO #1 和 #3（它們現在被「花費」了），並創建了兩個新的 UTXO：一個給 Eve，另一個找零的 UTXO 給 Alice。

這種模型實現了強大的功能：
- **可並行處理**：由於每個 UTXO 只能被花費一次，使用不同 UTXO 的交易不會衝突。只要每筆交易引用不同的 UTXO，礦工就可以同時驗證數千筆交易，而無需擔心雙重花費。
- **隱私性**：沒有一個全局帳戶會顯示你的總餘額。你的比特幣分散在多個 UTXO 中，這使得觀察者更難確定你的總財富。每個 UTXO 可能與不同的地址相關聯，進一步模糊了所有權模式。
- **簡單驗證**：每筆交易可以通過獨立驗證來檢查輸入的 UTXO 是否存在且未被花費，以及數字簽名是否有效。你不需要維護複雜的帳戶狀態，也不需要擔心交易順序影響餘額。
- **原子操作**：交易要麼完全成功（消耗所有輸入並創建所有輸出），要麼完全失敗。不存在部分狀態的風險，例如部分金額被扣除但未轉移。

<ArticleSection name="Ethereum" id="ethereum" level="h2" />

比特幣解決了數字支付的問題，但Vitalik Buterin發現了一個更大的機會：如果區塊鏈不僅僅是用於轉移資金，而是可以運行任何程式呢？這個願景促成了以太坊的誕生：第一個通用的區塊鏈電腦。

比特幣的UTXO模型在支付方面運作良好，但對於需要持久狀態、複雜邏輯以及不同程式之間可組合性的複雜應用來說，則顯得笨拙。

### 共識機制

以太坊最初使用工作量證明（Proof of Work），但在2022年的「The Merge」中轉換為權益證明（Proof of Stake）。這次轉換在保持安全性的同時帶來了重要的好處：
- 數學最終性：大約13分鐘後，交易變得數學上不可逆
- 能源效率：不再需要大量的電力消耗
- 未來升級：權益證明支持分片技術，將網絡分成平行鏈以提高吞吐量

### 帳戶模型

以太坊用熟悉的基於帳戶的餘額系統取代了比特幣的UTXO系統，實現了：
- 智能合約：駐留在區塊鏈上的程式，並維持自己的狀態
- 外部帳戶：用戶控制的帳戶，類似於比特幣地址
- 合約間調用：智能合約可以無縫地相互交互

在以太坊中，有兩種類型的帳戶：
- 外部擁有帳戶（EOAs）：由用戶使用私鑰控制，類似於比特幣地址。它們有餘額並可以發送交易。
- 合約帳戶：由程式碼控制，而非私鑰。它們有餘額，並存儲可執行程式碼和持久數據。

因此，在以太坊上，智能合約是駐留在區塊鏈上的自主程式，維持自己的狀態，並可以被其他帳戶調用。

這種帳戶模型實現了持久狀態——跨交易存活的數據。一個智能合約可以記住先前交互的信息，維持複雜的數據結構，並隨時間演變。

這使得像借貸協議、治理系統和複雜的金融工具等應用成為可能。

這一切都要歸功於以太坊虛擬機（EVM），它運行在每個節點上，使區塊鏈具有可編程性。它定義了可以運行的程序、執行方式以及所消耗的資源。

<ArticleSection name="Solana" id="solana" level="h2" />

以太坊證明了區塊鏈可以支持通用計算，但這一成功也暴露了可擴展性的限制。隨著去中心化應用的普及，網絡擁堵導致了高昂的交易費用和較慢的確認時間。

這些限制源於以太坊設計中的基本架構決策，而Solana試圖通過從基本原則重新設計核心區塊鏈組件的架構創新來解決這些問題。

### 共識機制

Solana 使用權益證明（Proof of Stake），但增加了一項關鍵創新：歷史證明（Proof of History）。Solana 不需要等待事件發生時間的共識，而是創建了一個加密時鐘，在共識之前為所有交易加上時間戳，讓驗證者可以並行處理交易，因為他們已經知道正確的順序。

這種時間排序使得共識速度更快：Solana 每 400 毫秒生成一個區塊，而以太坊需要 12 秒。

### Solana 虛擬機

由於智能合約共享全局狀態，以太坊虛擬機（EVM）按順序處理交易：當一個合約修改共享數據時，所有其他交易必須等待。隨著網絡使用量的增長，這會造成瓶頸。

Solana 徹底重新思考了這種架構：
- 無狀態程序：與以太坊智能合約內部存儲數據不同，Solana 程序是無狀態的。所有數據都存儲在獨立的賬戶中，程序從中讀取和寫入。這種分離使得並行處理成為可能，因為程序不會爭奪共享狀態。
- 交易並行化：Solana 的交易必須事先聲明將讀取和修改哪些賬戶。運行時可以同時在多個 CPU 核心上執行不衝突的交易。如果交易 A 修改賬戶 X，而交易 B 修改賬戶 Y，它們可以並行運行。
- 優化執行：SVM 使用基於寄存器的架構，而不是 EVM 的基於堆棧的方式，減少了計算過程中移動數據的開銷。程序編譯為本地機器碼，而不是字節碼，消除了解釋的開銷。
- 可預測成本：與以太坊多年前確定的固定 Gas 價格不同，Solana 使用動態費用市場，交易成本反映實際的網絡需求和計算資源消耗。

Solana 的結果是每秒可以處理超過 5,000 筆交易（TPS），相比之下，以太坊僅能處理 15 TPS，同時保持不到一秒的最終確認時間及去中心化。這種性能來自於架構上的決策，優先考慮平行執行，而非從單線程計算繼承而來的順序處理模式。