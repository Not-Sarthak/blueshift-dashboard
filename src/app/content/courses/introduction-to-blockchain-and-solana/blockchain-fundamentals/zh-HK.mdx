import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 區塊鏈基礎

現在你已經明白為什麼分佈式系統本質上是困難的，以及為什麼拜占庭將軍問題看似無法解決，讓我們來探討區塊鏈實際是如何運作的。

突破來自於結合了兩個關鍵創新：新穎的共識機制和巧妙運用的加密原語。

<ArticleSection name="共識機制" id="consensus-mechanisms" level="h2" />

計算機科學家其實在1980年代就數學上解決了拜占庭將軍問題，證明了要容忍 f 個叛徒，至少需要 `3f+1` 名參與者。

考慮一個經典案例：四位將軍中有一位叛徒。如果指揮將軍是叛徒，他可能會告訴兩位將軍「進攻」，而告訴另一位「撤退」。如果將軍們只遵循命令，計劃將會失敗。解決方案需要額外一輪的通信，所有將軍互相報告他們收到的命令。

這額外的通信輪次揭示了指揮官的欺騙行為。每位忠誠的將軍都會看到「進攻」是多數命令（2比1），並據此行動。因為所有忠誠的將軍得出相同的結論，達成了共識，叛徒被擊敗。

背後的數學解決方案是可行的，但不實用：
- 你必須事先確切知道所有參與者是誰
- 每對參與者之間需要多輪消息傳遞
- 通信複雜性呈指數增長
- 在無許可系統中，攻擊者可以創建無限的虛假身份

為了解決這個問題，區塊鏈不再計算身份，而是計算一些難以偽造的東西：計算工作量或抵押的資金。

### 工作量證明（POW）

在POW系統中，要提議接下來應該發生什麼，你必須證明你已完成昂貴的計算工作：
- 礦工將待處理的交易收集到一個「區塊」中
- 礦工必須找到一個隨機數（稱為「隨機數」），當它與區塊數據結合並進行哈希運算時，會產生一個以多個零開頭的結果
- 第一個找到這個數字的礦工將其解決方案廣播到網絡
- 其他參與者可以立即驗證解決方案是正確的，並接受新的區塊

這之所以可行，是因為找到隨機數可能需要數萬億次的隨機嘗試，但驗證解決方案只需毫秒。

每個區塊還引用了前一個區塊的哈希值，從而形成了一條鏈。要篡改歷史，攻擊者需要重新計算所有後續的計算工作，而誠實的礦工則會繼續延長真實的鏈。

安全假設是攻擊的電力成本高於攻擊者可能獲得的收益。

### 權益證明（Proof of Stake）

在權益證明系統中，參與者不是消耗電力，而是將自己的資金置於風險之中：
- 參與者將加密貨幣代幣鎖定作為抵押
- 協議隨機選擇驗證者來提議區塊，選擇的權重取決於他們的權益
- 被選中的驗證者提議區塊，其他驗證者投票接受或拒絕
- 誠實行為會獲得獎勵；不誠實行為會導致「削減」，即部分抵押的代幣被沒收或扣除。具體的懲罰因網絡和違規的嚴重程度而異。

這之所以可行，是因為驗證者有「利益相關」。攻擊網絡會摧毀他們抵押代幣的價值（通過削減）。此外，與工作量證明不同，權益證明可以提供經濟最終性。一旦區塊被超過三分之二的驗證者最終確定，逆轉它將需要攻擊者證明摧毀大量資本，從而使逆轉成本高昂到無法承受。

### 區塊鏈三難困境

正如分佈式系統面臨CAP定理一樣，區塊鏈也面臨自己的不可能取捨。區塊鏈三難困境指出，區塊鏈共識最多只能優化以下三個屬性中的兩個：
- 安全性：抵抗攻擊和審查
- 可擴展性：高交易吞吐量
- 去中心化：無單一控制點

比特幣選擇了安全性和去中心化，而非可擴展性。傳統支付系統如Visa則選擇了可擴展性和安全性，而非去中心化。當前的挑戰是尋找同時實現這三者的方法。

<ArticleSection name="Cryptographic Primitives" id="cryptographic-primitives" level="h2" />

共識機制解決了「誰來決定」的問題，但我們如何確保數據本身是可信的？

這就是密碼學基元的作用所在：經過數十年考驗的數學工具。

區塊鏈依賴三種關鍵的密碼學工具共同運作，從而創建一個不可篡改且可驗證的系統：

### 雜湊函數

想像一下，你需要驗證一份龐大的文件是否未被更改，但你只能發送一小段信息來證明。這正是雜湊函數的作用。

雜湊函數可以將任何輸入（無論是「Hello」這個詞、整部莎士比亞作品，還是一個包含數千筆交易的區塊）轉換為固定大小的輸出，這個輸出作為唯一的數字指紋。

雜湊函數有三個關鍵特性：

- **確定性：** 相同的輸入總是產生相同的輸出。
- **不可逆：** 該函數在一個方向上易於計算，但在反方向上計算則幾乎不可能。給定一個雜湊值，你無法輕易找到原始輸入，除非使用暴力破解或查找表。
- **雪崩效應：** 輸入中的微小變化（例如將一個字母大寫）會導致完全不同的輸出雜湊值。

以下是一些SHA-256雜湊值，展示了雪崩效應：

```plaintext
SHA-256("Hello") = 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969
SHA-256("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
```

注意，僅僅改變一個字母的大小寫就會產生完全不同的雜湊值。

雖然從任何輸入計算雜湊值是很簡單的，但反向過程在計算上是不可能的。給定一個雜湊值，你無法推斷出原始輸入，因為對於一個安全的雜湊函數來說，這需要比宇宙的年齡還長的時間。

在區塊鏈中，雜湊用於確保完整性。每個區塊都包含前一個區塊的雜湊值，從而形成一條不可破壞的鏈。如果有人試圖修改上週的某筆交易，他們將改變該區塊的雜湊值。由於下一個區塊引用的是舊的雜湊值，這種修改將破壞整條鏈。要修復這一點，他們需要在網絡繼續添加新區塊的同時，重新計算每個後續區塊的雜湊值，這幾乎是一個不可能完成的追趕遊戲。

### 數碼簽名

傳統的身份驗證依賴於共享的秘密（如密碼），但區塊鏈在沒有可信機構或安全渠道來共享秘密的情況下運行。因此，它們使用數碼簽名，這使得在不透露任何秘密信息的情況下進行身份驗證成為可能。

數碼簽名使用非對稱加密，這依賴於一種數學關係，該關係在一個方向上易於計算，但幾乎無法逆向計算。當您創建數碼簽名時，您會生成兩個數學相關的數字，稱為私鑰和公鑰；私鑰必須保密，而公鑰可以自由共享。

- 私鑰可用於為特定交易創建數碼簽名
- 簽名對您的私鑰和精確的交易內容都是唯一的。
- 任何人都可以使用您的公鑰來驗證該簽名只能由擁有相應私鑰的人創建。

沒有您的私鑰，即使擁有數百萬個先前的簽名，也無法計算出有效的簽名。為了防止攻擊者重放舊交易，每個簽名必須包含一個唯一的數據，通常是一個簡單的計數器，稱為「隨機數」（nonce），以確保每個簽名都是唯一的。

這創造了「不可否認性」：一旦你簽署了一筆交易，你就無法聲稱自己未曾授權。數學證明是無可辯駁的。

在區塊鏈中，錢包就是這樣運作的。你的「錢包」並不存儲加密貨幣；這些幣作為條目存在於區塊鏈上。相反，錢包存儲私鑰，並幫助創建數字簽名以證明你可以使用這些幣。它們本質上是數字簽名管理器。

### Merkle 樹

如何在不下載整個區塊的情況下，驗證特定交易是否存在於包含數千筆交易的區塊中？

Merkle 樹以二叉樹的形式組織數據，每個葉子節點代表一筆交易，每個父節點包含其兩個子節點的哈希值。這樣一直延續到樹的頂部，直到達到代表整個數據集的單一根哈希值。

因此，要證明任何交易存在於樹中，你只需要該交易和「Merkle 路徑」：用於重建根哈希的兄弟節點哈希值。這意味著對於一棵包含一百萬筆交易的樹，你只需要大約 20 個哈希值來證明包含性。

在區塊鏈中，Merkle 樹使得僅需幾千字節的證明就能極其輕鬆地驗證交易。安全性保證仍然相同：如果 Merkle 路徑驗證正確，你可以數學上確定該交易已包含在該區塊中。

<ArticleSection name="建立一個無需信任的系統" id="the-creation-of-a-trustless-system" level="h2" />

共識和加密基元共同作用，創建了一個「無需信任」的系統。歷史上首次，信任被放在數學而非人身上：
- 哈希函數確保任何對歷史數據的篡改都會立即顯現。
- 數字簽名在不需要任何可信中介驗證身份的情況下證明授權。
- Merkle 樹使得在不下載大量數據的情況下驗證複雜的聲明成為可能。

當結合共識機制時，這些工具創建了一個系統，讓每個參與者只需使用自己的計算資源，就能獨立驗證系統的整個歷史。無需信任的權威機構，無需共享的秘密，亦無中央故障點。

這就是為什麼區塊鏈代表著如此根本性的轉變。傳統系統通過控制訪問和限制參與來實現安全性。而區塊鏈則通過使驗證變得廉價且普遍，同時使欺詐變得昂貴且顯而易見來實現安全性。

理解這些基礎原理至關重要，因為它們定義了區塊鏈的能力和局限性。它們解釋了為什麼區塊鏈交易是不可逆的（設計上使得逆轉已完成交易的經濟成本極高），為什麼區塊鏈系統可以在沒有中央權威的情況下運行（每個人都可以獨立驗證所有內容），以及為什麼即使完全向公眾開放參與，系統仍然保持安全。