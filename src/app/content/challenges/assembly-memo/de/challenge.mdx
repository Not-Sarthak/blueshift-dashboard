import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

![Assembly Memo Challenge](/graphics/challenge-banners/assembly-memo.png)

# Assembly Memo

In dieser Einheit werden wir sBPF Assembly verwenden, um einen Logging-Mechanismus für unser Programm zu erstellen.

Die Einfachheit eines kompakten Memo-Programms ist der perfekte Ausgangspunkt für deine sBPF-Assembly-Reise!

Wenn du mit Assembly-Programmierung nicht vertraut bist, folge dem [Einführungskurs zu Assembly](/de/courses/introduction-to-assembly)

<ArticleSection name="Program Design" id="program-design" level="h2" />

Unser Programm wird einfach den richtigen Speicherort in das richtige Register setzen und dann den `sol_log_` Syscall ausführen. Es wird so aussehen:

```sbpf
.equ NUM_ACCOUNTS, 0x00
.equ DATA_LEN, 0x08
.equ DATA, 0x10
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]
  ldxdw r2, [r1+DATA_LEN]
  add64 r1, DATA
  call sol_log_
  exit
```

<ArticleSection name="Memory Offsets" id="memory-offsets" level="h2" />

Das Programm beginnt mit der Deklaration von drei `.equ` Konstanten, die das Speicherlayout unserer Instruktionsdaten definieren:

```sbpf
.equ NUM_ACCOUNTS, 0x00  ; Offset for number of accounts
.equ DATA_LEN, 0x08      ; Offset for data length
.equ DATA, 0x10          ; Offset for actual data
```

Diese Konstanten markieren die Byte-Offsets relativ zum Entry-Buffer-Zeiger in `r1`:
- `NUM_ACCOUNTS` (0x0000): Zeigt auf die Anzahl der Konten im Instruktionsdaten-Header zur Validierung
- `DATA_LEN` (0x08): Zeigt auf die Länge der Instruktionsdaten im Instruktionsdaten-Header
- `DATA` (0x10): Zeigt auf die Instruktionsdaten im Instruktionsdaten-Header

Im Gegensatz zu höheren Programmiersprachen, die das Speicherlayout abstrahieren, erfordert Assembly genaue Kenntnis darüber, wo jedes Datenelement gespeichert ist.

<ArticleSection name="Entrypoint and Initial Validation" id="entrypoint-and-validations" level="h2" />

```sbpf
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]   ; Load number of accounts into r0
```

Jedes sBPF-Programm beginnt mit einem globalen `.entrypoint` Symbol. Die Solana-Laufzeitumgebung stellt Konto- und Instruktionsdaten über das Register `r1` bereit.

Diese erste Anweisung lädt dann die Anzahl der Konten in `r0`. Da `r0` das Register ist, das die VM beim Beenden liest, erfüllt dies zwei Zwecke:
1. Es lädt die Kontoanzahl für unsere Verwendung
2. Es stellt sicher, dass das Programm automatisch fehlschlägt, wenn Konten übergeben werden (Wert ungleich Null in r0)

<ArticleSection name="Sol Log Syscall" id="sol-log-syscall" level="h2" />

Als nächstes bereiten wir die Argumente für den `sol_log_` Syscall vor:

```sbpf
ldxdw r2, [r1+DATA_LEN]   ; Load length of memo into r2
add64  r1, DATA           ; Adjust r1 to point to memo bytes
```

Diese Anweisungen richten die Argumente für `sol_log_` ein:
- `r2` erhält die Länge der Memo-Daten
- `r1` wird angepasst, um direkt auf die Memo-Bytes zu zeigen

Und danach rufen wir `sol_log_` auf und beenden:

```sbpf
call 16   ; Call sol_log_ (helper ID 16)
exit      ; Return using r0 value
```

<ArticleSection name="Fazit" id="conclusion" level="h2" />

Das Programm:
1. Ruft 16 (`sol_log_`) auf, um das Memo im Validator-Log auszugeben
2. Beendet mit dem Wert in `r0`