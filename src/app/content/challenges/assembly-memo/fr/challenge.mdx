import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

![Assembly Memo Challenge](/graphics/challenge-banners/assembly-memo.png)

# Assembly Memo

Dans cette unité, nous utiliserons l'assembleur sBPF pour créer un mécanisme de journalisation pour notre programme.

La simplicité d'un programme mémo de petite taille est le point de départ idéal pour votre voyage dans l'assembleur sBPF !

Si vous n'êtes pas familier avec la programmation en assembleur, suivez le [cours d'introduction à l'assembleur](/en/courses/introduction-to-assembly)

<ArticleSection name="Conception du programme" id="program-design" level="h2" />

Notre programme va simplement placer l'emplacement mémoire approprié dans le bon registre, puis effectuer l'appel système `sol_log_`. Cela ressemblera à ceci :

```sbpf
.equ NUM_ACCOUNTS, 0x00
.equ DATA_LEN, 0x08
.equ DATA, 0x10
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]
  ldxdw r2, [r1+DATA_LEN]
  add64 r1, DATA
  call sol_log_
  exit
```

<ArticleSection name="Décalages mémoire" id="memory-offsets" level="h2" />

Le programme commence par déclarer trois constantes `.equ` qui définissent la disposition mémoire de nos données d'instruction :

```sbpf
.equ NUM_ACCOUNTS, 0x00  ; Offset for number of accounts
.equ DATA_LEN, 0x08      ; Offset for data length
.equ DATA, 0x10          ; Offset for actual data
```

Ces constantes marquent les décalages d'octets relatifs au pointeur du tampon d'entrée dans `r1` :
- `NUM_ACCOUNTS` (0x0000) : Pointe vers le nombre de comptes dans l'en-tête des données d'instruction pour validation
- `DATA_LEN` (0x08) : Pointe vers la longueur des données d'instruction dans l'en-tête des données d'instruction
- `DATA` (0x10) : Pointe vers les données d'instruction dans l'en-tête des données d'instruction

Contrairement aux langages de haut niveau qui abstraient la disposition mémoire, l'assembleur nécessite de savoir exactement où se trouve chaque élément de données.

<ArticleSection name="Point d'entrée et validation initiale" id="entrypoint-and-validations" level="h2" />

```sbpf
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]   ; Load number of accounts into r0
```

Chaque programme sBPF commence par un symbole global `.entrypoint`. Le runtime Solana fournit les données de compte et d'instruction via le registre `r1`.

Cette première instruction charge ensuite le nombre de comptes dans `r0`. Comme `r0` est le registre que la VM lit à la sortie, cela sert deux objectifs :
1. Il charge le nombre de comptes pour notre utilisation
2. Il garantit que le programme échouera automatiquement si des comptes sont transmis (valeur non nulle dans r0)

<ArticleSection name="Appel système Sol Log" id="sol-log-syscall" level="h2" />

Ensuite, nous préparons les arguments pour l'appel système `sol_log_` :

```sbpf
ldxdw r2, [r1+DATA_LEN]   ; Load length of memo into r2
add64  r1, DATA           ; Adjust r1 to point to memo bytes
```

Ces instructions configurent les arguments pour `sol_log_` :
- `r2` reçoit la longueur des données du mémo
- `r1` est ajusté pour pointer directement vers les octets du mémo

Et après cela, nous appelons `sol_log_` et nous terminons :

```sbpf
call 16   ; Call sol_log_ (helper ID 16)
exit      ; Return using r0 value
```

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

Le programme :
1. Appelle 16 (`sol_log_`) pour afficher le mémo dans le journal du validateur
2. Se termine en utilisant la valeur dans `r0`