import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

![Assembly Memo Challenge](/graphics/challenge-banners/assembly-memo.png)

# Assembly Memo

Dalam unit ini kita akan menggunakan sBPF Assembly untuk membuat mekanisme pencatatan untuk program kita.

Kesederhanaan program memo berukuran kecil adalah titik awal yang sempurna untuk perjalanan sBPF assembly Anda!

Jika Anda belum terbiasa dengan pemrograman assembly, ikuti [kursus pengantar Assembly](/id/courses/introduction-to-assembly)

<ArticleSection name="Program Design" id="program-design" level="h2" />

Program kita akan menempatkan lokasi memori yang tepat ke dalam register yang tepat dan kemudian melakukan syscall `sol_log_`. Ini akan terlihat seperti ini:

```sbpf
.equ NUM_ACCOUNTS, 0x00
.equ DATA_LEN, 0x08
.equ DATA, 0x10
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]
  ldxdw r2, [r1+DATA_LEN]
  add64 r1, DATA
  call sol_log_
  exit
```

<ArticleSection name="Memory Offsets" id="memory-offsets" level="h2" />

Program dimulai dengan mendeklarasikan tiga konstanta `.equ` yang mendefinisikan tata letak memori dari data instruksi kita:

```sbpf
.equ NUM_ACCOUNTS, 0x00  ; Offset for number of accounts
.equ DATA_LEN, 0x08      ; Offset for data length
.equ DATA, 0x10          ; Offset for actual data
```

Konstanta-konstanta ini menandai byte-offset relatif terhadap pointer entry-buffer di `r1`:
- `NUM_ACCOUNTS` (0x0000): Menunjuk ke jumlah akun dalam header data instruksi untuk validasi
- `DATA_LEN` (0x08): Menunjuk ke panjang data instruksi dalam header data instruksi
- `DATA` (0x10): Menunjuk ke data instruksi dalam header data instruksi

Tidak seperti bahasa tingkat tinggi yang mengabstraksi tata letak memori, assembly mengharuskan kita mengetahui persis di mana setiap bagian data berada.

<ArticleSection name="Entrypoint and Initial Validation" id="entrypoint-and-validations" level="h2" />

```sbpf
.globl entrypoint
entrypoint:
  ldxdw r0, [r1+NUM_ACCOUNTS]   ; Load number of accounts into r0
```

Setiap program sBPF dimulai pada simbol global `.entrypoint`. Runtime Solana menyediakan data akun dan instruksi melalui register `r1`.

Instruksi pertama ini kemudian memuat jumlah akun ke dalam `r0`. Karena `r0` adalah register yang dibaca VM saat keluar, ini memiliki dua tujuan:
1. Memuat jumlah akun untuk penggunaan kita
2. Memastikan program akan gagal secara otomatis jika ada akun yang diteruskan (nilai bukan nol di r0)

<ArticleSection name="Sol Log Syscall" id="sol-log-syscall" level="h2" />

Selanjutnya, kita menyiapkan argumen untuk syscall `sol_log_`:

```sbpf
ldxdw r2, [r1+DATA_LEN]   ; Load length of memo into r2
add64  r1, DATA           ; Adjust r1 to point to memo bytes
```

Instruksi-instruksi ini menyiapkan argumen untuk `sol_log_`:
- `r2` menerima panjang data memo
- `r1` disesuaikan untuk menunjuk langsung ke byte-byte memo

Dan setelah itu, kita memanggil `sol_log_` dan keluar:

```sbpf
call 16   ; Call sol_log_ (helper ID 16)
exit      ; Return using r0 value
```

<ArticleSection name="Kesimpulan" id="conclusion" level="h2" />

Program ini:
1. Memanggil 16 (`sol_log_`) untuk mencetak memo ke log validator
2. Keluar menggunakan nilai dalam `r0`