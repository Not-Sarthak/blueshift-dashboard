# Abheben

Die `withdraw` Anweisung führt drei Hauptaufgaben aus:
- Abheben der `mint_x` und `mint_y` Token basierend auf der LP-Menge, die der Benutzer `burn` möchte.
- Berechnung des abzuhebenden Betrags und Überprüfung, dass der Betrag nicht geringer ist als die vom Benutzer festgelegten `mint_x` und `mint_y`.
- Verbrennen der richtigen Menge an `mint_lp` aus dem Benutzer-ATA.

> Wie im Abschnitt zur `initialize` Anweisung erwähnt, werden wir aus Optimierungsgründen alle `Associated Token Accounts` außerhalb unserer Anweisung initialisieren.

<ArticleSection name="Erforderliche Konten" id="required-accounts" level="h2" />

Nachfolgend sind die für diesen Kontext erforderlichen Konten aufgeführt:
- `user`: Der Benutzer, der den Token in die Liquidität des Amm abhebt. Muss ein `signer` sein.
- `mint_lp`: Das Mint-Konto, das die Liquidität des Pools repräsentiert. Muss als `mutable` übergeben werden.
- `vault_x`: Das Token-Konto, das alle in den Pool eingezahlten Token X enthält. Muss als `mutable` übergeben werden.
- `vault_y`: Das Token-Konto, das alle in den Pool eingezahlten Token Y enthält. Muss als `mutable` übergeben werden.
- `user_x_ata`: Das zugehörige Token-Konto des Benutzers für Token X. Dies ist das Zielkonto, auf das die Token X des Benutzers aus dem Pool übertragen werden. Muss als `mutable` übergeben werden.
- `user_y_ata`: Das zugehörige Token-Konto des Benutzers für Token Y. Dies ist das Zielkonto, auf das die Token Y des Benutzers aus dem Pool übertragen werden. Muss als `mutable` übergeben werden.
- `user_lp_ata`: Das zugehörige Token-Konto des Benutzers für LP-Token. Dies ist das Quellkonto, von dem LP-Token verbrannt werden. Muss als `mutable` übergeben werden.
- `config`: Das Konfigurationskonto für den AMM-Pool. Speichert alle relevanten Pool-Parameter und -zustände.
- `token program`: Das SPL-Token-Programmkonto. Dies ist erforderlich, um Token-Operationen wie Überweisungen und Prägungen durchzuführen. Muss `executable` sein.

Hier überlasse ich die Implementierung wieder dir:

```rust
pub struct WithdrawAccounts<'a> {
    pub user: &'a AccountInfo,
    pub mint_lp: &'a AccountInfo,
    pub vault_x: &'a AccountInfo,
    pub vault_y: &'a AccountInfo,
    pub user_x_ata: &'a AccountInfo,
    pub user_y_ata: &'a AccountInfo,
    pub user_lp_ata: &'a AccountInfo,
    pub config: &'a AccountInfo,
    pub token_program: &'a AccountInfo,
}

impl<'a> TryFrom<&'a [AccountInfo]> for WithdrawAccounts<'a> {
    type Error = ProgramError;

    fn try_from(accounts: &'a [AccountInfo]) -> Result<Self, Self::Error> {
        //..
    }
}
```

<ArticleSection name="Instruction Data" id="instruction-data" level="h2" />

Hier sind die Instruktionsdaten, die wir übergeben müssen:
- `amount`: Die Menge an LP-Token, die der Benutzer verbrennen möchte. Muss ein `[u64]` sein
- `min_x`: Die Mindestmenge an Token X, die der Benutzer abheben möchte. Muss ein `[u64]` sein
- `min_y`: Die Mindestmenge an Token Y, die der Benutzer abheben möchte. Muss ein `[u64]` sein
- `expiration`: Das Ablaufdatum dieser Order. Wichtig, um sicherzustellen, dass die Transaktion innerhalb einer bestimmten Zeit ausgeführt werden muss. Muss ein `[i64]` sein

Wir werden die Implementierung für das `WithdrawInstructionData` genauso wie bei der Initialisierung handhaben. Daher überlasse ich dir die Implementierung:

```rust
pub struct WithdrawInstructionData {
    pub amount: u64,
    pub min_x: u64,
    pub min_y: u64,
    pub expiration: i64,
}

impl<'a> TryFrom<&'a [u8]> for WithdrawInstructionData {
    type Error = ProgramError;

    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        //..
    }
}
```

> Stelle sicher, dass alle Beträge wie `amount`, `min_y` und `min_x` größer als null sind und dass die Order noch nicht abgelaufen ist, indem du das `Clock` Sysvar verwendest.

<ArticleSection name="Instruction Logic" id="instruction-logic" level="h2" />

Wir beginnen mit der Deserialisierung sowohl des `instruction_data` als auch des `accounts`.

Dann müssen wir:
- Das `Config`-Konto laden, um alle darin enthaltenen Daten zu erfassen. Wir können dies mit dem `Config::load()`Helper tun.
- Überprüfen, ob der `AmmState` gültig ist (also nicht gleich `AmmState::Disabled`).
- Die Ableitung von `vault_x` und `vault_y` prüfen, um sicherzustellen, dass es sich um Associated Token Accounts handelt.
- Alle beteiligten Token-Konten deserialisieren und die darin enthaltenen Daten verwenden, um den abzuhebenden Betrag mit dem `constant-product-curve`Crate zu berechnen und den Slippage wie folgt zu überprüfen:

```rust
let mint_lp = unsafe { Mint::from_account_info_unchecked(self.accounts.mint_lp)? };
let vault_x = unsafe { TokenAccount::from_account_info_unchecked(self.accounts.vault_x)? };
let vault_y = unsafe { TokenAccount::from_account_info_unchecked(self.accounts.vault_y)? };

let (x, y) = match mint_lp.supply() == self.instruction_data.amount {
    true => (vault_x.amount(), vault_y.amount()),
    false => {
        let amounts = ConstantProduct::xy_withdraw_amounts_from_l(
            vault_x.amount(),
            vault_y.amount(),
            mint_lp.supply(),
            self.instruction_data.amount,
            6,
        )
        .map_err(|_| ProgramError::InvalidArgument)?;

        (amounts.x, amounts.y)
    }
};

// Check for slippage
if !(x >= self.instruction_data.min_x && y >= self.instruction_data.min_y) {
    return Err(ProgramError::InvalidArgument);
}
```

- Übertrage die Beträge aus den Tresoren auf die Token-Konten des Benutzers und verbrenne die entsprechende Menge an LP-Tokens vom Token-Konto des Benutzers

> Der `authority` von `vault_x` und `vault_y` ist das `config` Konto

Du solltest kompetent genug sein, um dies selbständig zu tun, daher überlasse ich dir die Implementierung:

```rust
pub struct Withdraw<'a> {
    pub accounts: WithdrawAccounts<'a>,
    pub instruction_data: WithdrawInstructionData,
}

impl<'a> TryFrom<(&'a [u8], &'a [AccountInfo])> for Withdraw<'a> {
    type Error = ProgramError;

    fn try_from((data, accounts): (&'a [u8], &'a [AccountInfo])) -> Result<Self, Self::Error> {
        let accounts = WithdrawAccounts::try_from(accounts)?;
        let instruction_data = WithdrawInstructionData::try_from(data)?;

        // Return the initialized struct
        Ok(Self {
            accounts,
            instruction_data,
        })
    }
}

impl<'a> Withdraw<'a> {
    pub const DISCRIMINATOR: &'a u8 = &2;

    pub fn process(&mut self) -> ProgramResult {
        //..

        Ok(())
    }
}
```
