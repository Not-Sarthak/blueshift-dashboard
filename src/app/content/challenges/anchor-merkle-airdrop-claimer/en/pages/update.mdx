import { ArticleSection } from "../../../../../components/ArticleSection/ArticleSection";
import { Codeblock } from "../../../../../components/Codeblock/Codeblock";

<ArticleSection name="Updated" id="update" level="h2" />

We can now move to the `update` instruction, the easiest instruction of this program, that lives in the `update.rs` and will perform these actions:
- Check if the `Signer` performing the action is the authority saved in the `AirdropState` account.
- Update the root saved in the `AirdropState` account.

### Accounts

The accounts needed in this context are:
- `airdrop_state`: PDA that stores the airdrop configuration and merkle tree root
- `authority`: The signer who has permission to update the `airdrop_state`

And with all the constraint it will look something like this:

<Codeblock lang="rust">
```rust
#[derive(Accounts)]
pub struct Update<'info> {
  #[account(
    mut, 
    has_one = authority,
    seeds = [b"merkle_tree".as_ref(), airdrop_state.mint.key().to_bytes().as_ref()],
    bump = airdrop_state.bump
  )]
  pub airdrop_state: Account<'info, AirdropState>,
  pub authority: Signer<'info>,
}
```
</Codeblock>

### Logic 

After defining the accounts, we implement the core logic using helper functions as methods on the account struct.

<Codeblock lang="rust">
```rust
impl<'info> Update<'info> {
    /// # Update the Root
    fn update_root(&mut self, new_root: [u8; 32]) -> Result<()> {
        self.airdrop_state.merkle_root = new_root;

        Ok(())
    }
}
```
</Codeblock>

Finally, we create the handler function that orchestrates these helper methods:

<Codeblock lang="rust">
```rust
pub fn handler(ctx: Context<Update>, new_root: [u8; 32]) -> Result<()> {
    // Update the AirdropState Root
    ctx.accounts.update_root(new_root)?;

    Ok(())
}
```
</Codeblock>