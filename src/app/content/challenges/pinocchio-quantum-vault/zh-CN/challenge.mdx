import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 量子保险库

![匹诺曹量子保险库挑战](/graphics/challenge-banners/pinocchio-quantum-vault.png)

保险库是去中心化金融（DeFi）中的一个基本构建模块，为用户提供了一种安全存储资产的方式。

在本次挑战中，我们将构建一个使用Winternitz签名进行交易验证的保险库。这非常有趣，因为Winternitz签名是第一个在Solana上集成的后量子签名。

> 如果您不熟悉Winternitz签名，请先阅读[Solana上的Winternitz签名](/zh-CN/courses/winternitz-signatures-on-solana)以了解核心概念和基础密码学。

在本次挑战中，我们将更新我们在[匹诺曹保险库挑战](/zh-CN/challenges/pinocchio-vault)中构建的简单Lamport保险库，使其支持Winternitz签名作为交易验证方法。

<ArticleSection name="安装" id="installation" level="h2" />

在开始之前，请确保已安装Rust和Pinocchio。然后，在终端中运行以下命令：

```bash
# create workspace
cargo new blueshift-pinocchio-quantum-vault --lib --edition 2021
cd blueshift-pinocchio-quantum-vault
```

添加`pinocchio`、`pinocchio-system`、`solana-nostd-sha256`和`solana-winternitz`：

```bash
cargo add pinocchio pinocchio-system solana-nostd-sha256 solana-winternitz
```

在`Cargo.toml`中声明crate类型，以在`target/deploy`中生成部署工件：

```toml
[lib]
crate-type = ["lib", "cdylib"]
```

现在，您已经准备好编写量子保险库程序了。

<ArticleSection name="模板" id="template" level="h2" />

这次，我们将把程序分成小而集中的模块，而不是将所有内容放在`lib.rs`中。文件夹结构大致如下：

```
src
├── instructions
│       ├── close.rs
│       ├── open.rs
│       ├── mod.rs
│       └── split.rs
└── lib.rs
```

**注意**：请记得将程序ID更改为`22222222222222222222222222222222222222222222`，因为我们在底层使用它来测试您的程序。

`lib.rs`中的入口点与我们在[Pinocchio简介课程](/zh-CN/courses/introduction-to-pinocchio)中介绍的内容非常相似。

```rust
pub mod instructions;
use instructions::*;

use pinocchio::{
    account_info::AccountInfo, program_entrypoint, program_error::ProgramError,
    pubkey::Pubkey, ProgramResult,
};

program_entrypoint!(process_instruction);

// 22222222222222222222222222222222222222222222
pub const ID: Pubkey = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {    
    match instruction_data.split_first() {
        Some((OpenVault::DISCRIMINATOR, data)) => OpenVault::try_from((data, accounts))?.process(),
        Some((SplitVault::DISCRIMINATOR, data)) => SplitVault::try_from((data, accounts))?.process(),
        Some((CloseVault::DISCRIMINATOR, data)) => CloseVault::try_from((data, accounts))?.process(),
        _ => Err(ProgramError::InvalidInstructionData)
    }
}
```

我们不需要为此设置任何状态，因此我们将直接进入创建指令的部分。