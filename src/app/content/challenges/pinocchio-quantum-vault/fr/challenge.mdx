import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# Le Coffre-fort Quantique

![Défi Pinocchio Coffre-fort Quantique](/graphics/challenge-banners/pinocchio-quantum-vault.png)

Un coffre-fort est un élément fondamental dans la DeFi qui offre aux utilisateurs un moyen sécurisé de stocker leurs actifs.

Dans ce défi, nous allons construire un coffre-fort qui utilise les signatures Winternitz pour la vérification des transactions. C'est particulièrement intéressant car la signature Winternitz est la première signature post-quantique intégrée sur Solana.

> Si vous n'êtes pas familier avec la signature Winternitz, commencez par lire [Signature Winternitz sur Solana](/en/courses/winternitz-signatures-on-solana) pour comprendre les concepts fondamentaux et la cryptographie sous-jacente.

Dans ce défi, nous allons mettre à jour le coffre-fort lamport simple que nous avons construit dans le [Défi Coffre-fort Pinocchio](/en/challenges/pinocchio-vault) pour permettre l'utilisation des signatures Winternitz comme méthode de vérification pour les transactions.

<ArticleSection name="Installation" id="installation" level="h2" />

Avant de commencer, assurez-vous que Rust et Pinocchio sont installés. Ensuite, exécutez ce qui suit dans votre terminal :

```bash
# create workspace
cargo new blueshift-pinocchio-quantum-vault --lib --edition 2021
cd blueshift-pinocchio-quantum-vault
```

Ajoutez `pinocchio`, `pinocchio-system`, `solana-nostd-sha256` et `solana-winternitz` :

```bash
cargo add pinocchio pinocchio-system solana-nostd-sha256 solana-winternitz
```

Déclarez les types de crate dans `Cargo.toml` pour générer des artefacts de déploiement dans `target/deploy` :

```toml
[lib]
crate-type = ["lib", "cdylib"]
```

Vous êtes maintenant prêt à écrire votre programme de coffre-fort quantique.

<ArticleSection name="Modèle" id="template" level="h2" />

Cette fois, nous allons diviser le programme en petits modules ciblés au lieu de tout placer dans `lib.rs`. L'arborescence des dossiers ressemblera à peu près à ceci :

```
src
├── instructions
│       ├── close.rs
│       ├── open.rs
│       ├── mod.rs
│       └── split.rs
└── lib.rs
```

**Remarque** : N'oubliez pas de changer l'ID du programme en `22222222222222222222222222222222222222222222` car nous l'utilisons en arrière-plan pour tester votre programme.

Le point d'entrée dans `lib.rs` est très similaire à ce que nous avons vu dans le [Cours d'introduction à Pinocchio](/en/courses/introduction-to-pinocchio).

```rust
pub mod instructions;
use instructions::*;

use pinocchio::{
    account_info::AccountInfo, program_entrypoint, program_error::ProgramError,
    pubkey::Pubkey, ProgramResult,
};

program_entrypoint!(process_instruction);

// 22222222222222222222222222222222222222222222
pub const ID: Pubkey = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {    
    match instruction_data.split_first() {
        Some((OpenVault::DISCRIMINATOR, data)) => OpenVault::try_from((data, accounts))?.process(),
        Some((SplitVault::DISCRIMINATOR, data)) => SplitVault::try_from((data, accounts))?.process(),
        Some((CloseVault::DISCRIMINATOR, data)) => CloseVault::try_from((data, accounts))?.process(),
        _ => Err(ProgramError::InvalidInstructionData)
    }
}
```

Nous n'avons pas besoin de configuration d'état pour cela, nous allons donc passer directement à la création de nos instructions.