import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# 量子保險庫

![Pinocchio 量子保險庫挑戰](/graphics/challenge-banners/pinocchio-quantum-vault.png)

保險庫是去中心化金融（DeFi）中的一個基本構建模塊，為用戶提供安全存儲資產的方式。

在這個挑戰中，我們將構建一個使用 Winternitz 簽名進行交易驗證的保險庫。這特別有趣，因為 Winternitz 簽名是第一個在 Solana 上集成的後量子簽名。

> 如果你不熟悉 Winternitz 簽名，請先閱讀 [Solana 上的 Winternitz 簽名](/zh-HK/courses/winternitz-signatures-on-solana) 以了解核心概念和基礎加密技術。

在這個挑戰中，我們將更新我們在 [Pinocchio 保險庫挑戰](/zh-HK/challenges/pinocchio-vault) 中構建的簡單 Lamport 保險庫，以允許使用 Winternitz 簽名作為交易驗證方法。

<ArticleSection name="安裝" id="installation" level="h2" />

在開始之前，請確保已安裝 Rust 和 Pinocchio。然後，在終端中運行以下命令：

```bash
# create workspace
cargo new blueshift-pinocchio-quantum-vault --lib --edition 2021
cd blueshift-pinocchio-quantum-vault
```

添加 `pinocchio`、`pinocchio-system`、`solana-nostd-sha256` 和 `solana-winternitz`：

```bash
cargo add pinocchio pinocchio-system solana-nostd-sha256 solana-winternitz
```

在 `Cargo.toml` 中聲明 crate 類型，以在 `target/deploy` 中生成部署工件：

```toml
[lib]
crate-type = ["lib", "cdylib"]
```

現在你已準備好編寫你的量子保險庫程序。

<ArticleSection name="模板" id="template" level="h2" />

這次，我們將把程序分成小而專注的模塊，而不是將所有內容放在 `lib.rs` 中。文件夾結構大致如下：

```
src
├── instructions
│       ├── close.rs
│       ├── open.rs
│       ├── mod.rs
│       └── split.rs
└── lib.rs
```

**注意**：請記得將程序 ID 更改為 `22222222222222222222222222222222222222222222`，因為我們在後台使用它來測試你的程序。

`lib.rs` 中的入口點與我們在 [Pinocchio 入門課程](/zh-HK/courses/introduction-to-pinocchio) 中介紹的非常相似。

```rust
pub mod instructions;
use instructions::*;

use pinocchio::{
    account_info::AccountInfo, program_entrypoint, program_error::ProgramError,
    pubkey::Pubkey, ProgramResult,
};

program_entrypoint!(process_instruction);

// 22222222222222222222222222222222222222222222
pub const ID: Pubkey = [
    0x0f, 0x1e, 0x6b, 0x14, 0x21, 0xc0, 0x4a, 0x07, 
    0x04, 0x31, 0x26, 0x5c, 0x19, 0xc5, 0xbb, 0xee, 
    0x19, 0x92, 0xba, 0xe8, 0xaf, 0xd1, 0xcd, 0x07, 
    0x8e, 0xf8, 0xaf, 0x70, 0x47, 0xdc, 0x11, 0xf7, 
];

fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {    
    match instruction_data.split_first() {
        Some((OpenVault::DISCRIMINATOR, data)) => OpenVault::try_from((data, accounts))?.process(),
        Some((SplitVault::DISCRIMINATOR, data)) => SplitVault::try_from((data, accounts))?.process(),
        Some((CloseVault::DISCRIMINATOR, data)) => CloseVault::try_from((data, accounts))?.process(),
        _ => Err(ProgramError::InvalidInstructionData)
    }
}
```

我們不需要為此設置任何狀態，因此我們將直接進入創建指令的部分。